Erlang JavaScript Parse Transform

Пацаны, я сегодня шел по улице и увидел типа в майке ClojureScript...
Из народного творчества

Мы стримим ивенты с сервера на клиент по вебсокету. Вообще говоря серверные
ивенты в виде кусков компилируемого джаваскрипта -- это совершенно нормальный
ивентинг в условиях где приложение размазано, вроде как и клиент-сайд, а вроде
как и нет. В N2O ивенты которые приходят в виде джаваскрипта попадают сразу на
обработчик eval главной страницы, дата ивенты попадают в контролы. Но пока в
N2O нет клиентской инфраструктуры. В скором будущем она появится в виде
bacon.js библиотеки на клиенте, вакансия на библиотеку клиентского лейаута и
рендеринга пока открыта.

До сегоднешнего дня N2O был почти идельной библиотекой, которую мы
оптимизировали вылизали и сделали настолько простой, удобной и понятно
насколько это вообще возможно для Веб Фреймворка, количество ядра не превышает
2000 строк кода. Ни одной лишний функции или булшита. Только вебсокеты, роутинг
и стриминг ивентов. N2O имеет встроенный PubSub GProc для прототипирования
связей между процессами и организации шины, который можно будет в будущем
заменить на универсальную библиотеку месадж баса MQS, которая будет
поддерживать RabbitMQ и возможно даже Azure Message Bus :)

Почему почти идеальной, потому что корневые базовые события и настройка
контрольных элементов писались в ручную в виде JavaScript строк. Я думаю все
вообще кто писал на джаваскрипте в виде строк понимают угнетенность момента.
Так вот на этих выходных я вляз да и оформил Раннее написанный прототип
JavaScript компилятора в виде Парсер Транформации для Erlang.

Эта парсер трансформация поддерживает два режима работы:

- Макросы, которые компилируются в JavaScript строки на этапе Erlang-компиляции
- Полноценной JavaScript приложение готовое для запуска в Браузере или под
Node.js

Да-да, вам не послышалось вы компилируете JavaScript приложения с помощью erlc
эрланг компилятора! Первый вариант используется для серверных компонент которые
упраляют клиентом напрямую создавая события в eval канале, а второй вариант
разрабатывается нами для создания полноценной клиентской инфраструктуры на
Erlang, потому что троллинг пацанов которые пишут на Clojure изрядно достал нас
и мы решили выступить со своей технологией которая имеет клиентскую и серверную
инфраструктуры, работает на WebSocket, SPDY, Xen, поддерживает эрланг
типизацию, на выходе генерирует читаемый код не нуждающийся в source-map, и
естественным образом встраивается в компилятор Эрланга.

Вот пример sample.erl:

-module(sample).
-compile({parse_transform, shen}).
-jsmacro([tabshow/0,doc_ready/1,event/3]).

Вы должны указать что вы используете Erlang Shen парсер трансформ в любом
эрланг модуле. -jsmacro - это атрибут который задает список всех функций,
которые нужно заменить на JavaScript строки на этапе компиляции эрланг модуля.
для экспорта функций в JS, который можно запустить под нодой, нужно указать
другой аттрибут -js, но много от него не ждите факториалы вы сможете посчитать,
но без развитой клиентской инфраструктуры это бессмысленно, первым делом мы
напишем обертку вокруг bacon.js. Вакансии на UI движки пока открыты, возможно
сами на эрланге напишем свой.
tabshow() ->
    X = jq("a[data-toggle=tab]"),
    X:on("show", fun(E) -> T = jq(E:at("target")), tabshow(T:attr("href")) end).

doc_ready(E) ->
    D = jq(document),
    D:ready(fun() -> T = jq("a[href=\"#" ++ E ++ "\"]"), T:tab("show") end).

event(A,B,C) ->
    ws:send('Bert':encodebuf(
        [{source,'Bert':binary(A)},
         {x,C},
         {pickle,'Bert':binary(B)},
         {linked,C}])).

main() ->
    Script1 = tabshow(),
    Script2 = event(1, 2, 3),
    Script3 = doc_ready(wf:js_list("tab")),

io:format("tabshow/0:~n~s~nevent/3:~n~s~ndoc_ready/1:~n~s~n",[Script1,Script2,Sc
ript3]).

Эти функции компилируютя в такое:
$ erlc sample.erl
$ erl
> sample:main().

tabshow/0:
var x = $('a[data-toggle=tab]');
x.on('show',function(e) {
    var t = $(e['target']);
    return tabshow(t.attr('href'));
});

event/3:
ws.send(Bert.encodebuf({source:Bert.binary(1),x:3,pickle:Bert.binary(2),linked:3
}));

doc_ready/1:
var d = $(document);
d.ready(function() {
    var t = $('a[href="#' + 'tab' + '"]');
    return t.tab('show');
});

Сегодня запустили это в продакшин, вот модуль-доказательство.
Страница проекта: https://github.com/5HT/shen
Следите, скоро мы будем писать node.js, angular.js и meteor.js приложения на
Эрланге :) CoffeeScript уже история :)

