<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>2022-01-17 Anders: –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ç–æ—Ä –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏</title>
    <link rel="stylesheet" href="../../blank.css" />
    <link rel="stylesheet" href="../../journal.css" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2022-01-17</a>
</nav>
<main>
    <section>

        <h3>Anders: –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ç–æ—Ä –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏</h3>

        <p>–í–µ—Ä–∏—Ñ–∏–∫–∞—Ç–æ—Ä –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏ <a href="https://github.com/groupoid/anders">Anders</a> –≤—Å–µ–≥–æ –ª–∏—à—å –æ–¥–∏–Ω –∏–∑ —Ç—Ä–µ—Ö –≥–æ–º–æ—Ç–æ–ø–∏—á–µ—Å–∫–∏—Ö –ø—Ä—É–≤–µ—Ä–æ–≤ –ì—Ä—É–ø–æ–∏–¥ –ò–Ω—Ñ–∏–Ω–∏—Ç–∏.
           –î—Ä—É–≥–∏–µ –¥–≤–∞ &mdash; —ç—Ç–æ: 1) –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º <a href="https://github.com/groupoid/hurricane">Hurricane</a> —Å–∏—Å—Ç–µ–º—ã —Ç–∏–ø–æ–≤ HoTT-I,
           –∫–æ—Ç–æ—Ä–∞—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ —Ç–µ–æ—Ä–µ–º –ø—Ä—É–≤–µ—Ä–µ JetBrains Arend, –∞ —Ç–∞–∫–∂–µ 2) –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ç–æ—Ä
           –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º <a href="https://github.com/groupoid/castle.bravo">Castle Bravo</a> –∞–≤—Ç–æ—Ä—Å–∫–æ–π —Å–∏—Å—Ç–µ–º—ã —Ç–∏–ø–æ–≤ HoTT-‚àÇ. –í –æ—Ç–ª–∏—á–∏–∏ –æ—Ç Anders,
           –æ–±–µ —Å–∏—Å—Ç–µ–º—ã HoTT-I –∏ HoTT-‚àÇ –æ–±–ª–∞–¥–∞—é—Ç –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–º —Å–≤–æ–π—Å—Ç–≤–æ–º Œ≤-–¥–µ—Ñ–∏–Ω–∏—Ü–∏–∞–ª—å–Ω–æ–≥–æ —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ –ø—É—Ç–µ–π.
           –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ –Ω–∏—Ö, –æ–Ω–∏ —Ç–æ–∂–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–µ! –≠—Ç–∞ –∂–µ —Å—Ç–∞—Ç—å—è –ø–æ—Å–≤—è—â–µ–Ω–∞ —Ü–µ–ª–∏–∫–æ–º CCHM –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É –≥–æ–º–æ—Ç–æ–ø–∏—á–µ—Å–∫–æ–π
           —Å–∏—Å—Ç–µ–º—ã —Ç–∏–ø–æ–≤ —Å –¥–≤—É–º—è —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞–º–∏, –∏–∑–≤–µ—Å—Ç–Ω–æ–π –∫–∞–∫ HTS —Å–∏—Å—Ç–µ–º–∞ –í–æ–µ–≤–æ–¥—Å–∫–æ–≥–æ –∏–ª–∏
           —Å–∏—Å—Ç–µ–º–∞ 2LTT –ê–Ω–Ω–µ–Ω–∫–æ–≤–∞-–ö–∞–ø—Ä–∏–æ—Ç—Ç–∏-–ö—Ä–∞—É—Å–∞-–°–∞—Ç—Ç–ª–µ—Ä–∞. –ö—Ä–æ–º–µ —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ –Ω–∞ –ø—Ä–µ—Ç–∏–ø–∞—Ö, –ê–Ω–¥–µ—Ä—Å —Å–æ–¥–µ—Ä–∂–∏—Ç
           –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø—Ä–∏–º–∏—Ç–∏–≤–∞ —Å—Ç–µ–∫ –¥–µ –†–∞–º–∞ –ß–µ—Ä—É–±–∏–Ω–∏-–®—Ä–∞–π–±–µ—Ä–∞, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –µ–≥–æ –ø—Ä–∏–≥–æ–¥–Ω—ã–º –¥–ª—è –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è
           –∫–æ–≥–æ–º–æ–ª–æ–≥–∏–π –∏ —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–æ–π –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–∏.
        </div></p>

        <figure><code>type exp =
  | EPre of Z.t | EKan of Z.t | EVar of name | EHole
  | EPi of exp * (name * exp) | ELam of exp * (name * exp) | EApp of exp * exp
  | ESig of exp * (name * exp) | EPair of tag * exp * exp | EFst of exp | ESnd of exp
  | EId of exp | ERef of exp | EJ of exp | EField of exp * string
  | EPathP of exp | EPLam of exp | EAppFormula of exp * exp
  | EI | EDir of dir | EAnd of exp * exp | EOr of exp * exp | ENeg of exp
  | ETransp of exp * exp | EHComp of exp * exp * exp * exp
  | EPartial of exp | EPartialP of exp * exp | ESystem of exp System.t
  | ESub of exp * exp * exp | EInc of exp * exp | EOuc of exp
  | EGlue of exp | EGlueElem of exp * exp * exp | EUnglue of exp
  | EEmpty | EIndEmpty of exp
  | EUnit | EStar | EIndUnit of exp
  | EBool | EFalse | ETrue | EIndBool of exp
  | EW of exp * (name * exp) | ESup of exp * exp | EIndW of exp * exp * exp
  | EIm of exp | EInf of exp | EIndIm of exp * exp | EJoin of exp
</code></figure>

        <h4>–ö–æ—Å–º–æ—Å –∏–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –≤—Å–µ–ª–µ–Ω–Ω—ã—Ö</h4>

<p>–ù–∞—á–∞—Ç—å —Å—Ç–∞—Ç—å—é —Ö–æ—Ç–∏–º —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ —Ç–∞–π–ø —á–µ–∫–µ—Ä–∞. –í —Å—É—â–Ω–æ—Å—Ç–∏ —Å–≤–æ–µ–π —Ç–∞–π–ø —á–µ–∫–µ—Ä —ç—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –Ω–∞–¥ —è–∑—ã–∫–æ–º –≤—ã—Ä–∞–∂–µ–Ω–∏–π exp.
   –ë—É–¥–µ–º —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ —Ñ—É–Ω–∫—Ü–∏–π —Ç–∞–π–ø —á–µ–∫–µ—Ä–∞ –ø–æ—Å—Ç—Ä–æ—á–Ω–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–∏—Ç–∏–º–∏—Ç–∏–≤–∞ –∏–∑ –¥–µ—Ä–µ–≤–∞ exp.</P>

<figure><code>type exp = | EPre of Z.t | EKan of Z.t | EVar of name | EHole </code></figure>

<p>–°–∏—Å—Ç–µ–º–∞ HTS (–∏–ª–∏ 2LTT) —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏–∑—É–µ—Ç—Å—è –Ω–∞–ª–∏—á–∏–µ–º –¥–≤—É—Ö –∏–µ—Ä–∞—Ä—Ö–∏–π –ø—Ä–µ–¥–∏–∫–∞—Ç–∏–≤–Ω—ã—Ö
   –≤—Å–µ–ª–µ–Ω–Ω—ã—Ö U<sub>i</sub> –¥–ª—è —Ñ–∏–±—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∏ V<sub>j</sub> –¥–ª—è –ø—Ä–µ—Ç–∏–ø–æ–≤,
   –≥–¥–µ –∏ –∂–∏–≤–µ—Ç –≥–æ–º–æ—Ç–æ–ø–∏—á–µ—Å–∫–∏–π –º–Ω–æ–≥–æ–º–µ—Ä–Ω—ã–π –æ—Ç—Ä–µ–∑–æ–∫. –¢–∞–∫–∂–µ –≤ —è–¥—Ä–µ —Ç–∞–π–ø —á–µ–∫–µ—Ä–∞ –æ–±—ã—á–Ω–æ
   –Ω–∞—Ö–æ–¥—è—Ç—Å—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã –¥–ª—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ –¥—ã—Ä —É–¥–æ–±–Ω—ã—Ö –¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤.
  –£—Ä–∞–≤–Ω–µ–Ω–∏—è –¥–ª—è —ç—Ç–∏—Ö –ø—Ä–∏–º–∏—Ç–∏–≤–æ–≤ –±—É–¥—É—Ç –¥–∞–Ω—ã –≤ —ç—Ç–æ–º –ø–∞—Ä–∞–≥—Ä–∞—Ñ–µ.</p>

<p>–°–∞–º —Ç–∞–π–ø—á–µ–∫–µ—Ä —É—Å—Ç—Ä–æ–µ–Ω —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º (—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –ø—Ä–∞–∫—Ç–∏–∫–∞, —Å–º. –Ω–∞–ø—Ä–∏–º–µ—Ä —Å—Ç–∞–≤—à–∏–µ —É–∂–µ –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–º–∏
—Ç–∞–π–ø—á–µ–∫–µ—Ä—ã Mini-TT –∏–ª–∏ cubicaltt), —á—Ç–æ –¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å–∞ –±–µ—Ç–∞-–Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏ (—ç–≤–∞–ª—É–∞—Ü–∏–∏) –∏–ª–∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
–≤—ã—Ä–∞–∂–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ, –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –¥–ª—è –Ω—É–∂–¥ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã—Ö
–≤—ã—á–∏—Å–ª–µ–Ω–∏–π.</p>

<figure><code>type value = | VKan of Z.t | VPre of Z.t | Var of name * value | VHole</code></figure>

<p>–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ —Ç–∞–π–ø—á–µ–∫–µ—Ä–∞ –≤—ã–≥–ª—è–¥–∏—Ç —Ç–∞–∫:</p>

<figure><code>and check ctx (e0 : exp) (t0 : value) = traceCheck e0 t0; try match e0, t0 with</code></figure>

<p>–ê–ª–≥–æ—Ä–∏—Ç–º –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –∏ –∑–≤—É—á–∏—Ç —Ç–∞–∫: –¥–ª—è —Ç–∏–ø–æ–≤–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –∏ –µ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –º—ã –±–µ—Ä–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä
—Ç–∏–ø–æ–≤–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –≤—ã–≤–æ–¥–∏–º –µ–≥–æ —Ç–∏–ø –∏ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –∑–∞–¥–∞–Ω—ã–º —Ç–∏–ø–æ–≤—ã–º –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º. –ï—Å–ª–∏ –æ–Ω–∏ —Å–æ–≤–ø–∞–¥–∞—é—Ç —Ç–æ –≤—Å–µ —Ö–æ—Ä–æ—à–æ,
–µ—Å–ª–∏ –Ω–µ—Ç -- —Ç–æ –æ—à–∏–±–∫–∞ —Ç–∏–ø–∏–∑–∞—Ü–∏–∏. –î–∞–ª—å—à–µ –∏–¥–µ—Ç —Å–ø–∏—Å–æ–∫ –ø–∞—Ç—Ç–µ—Ä–Ω-–º–∞—Ç—á–∏–Ω–≥ —É—Ä–∞–≤–Ω–µ–Ω–∏–π –≤—Å–µ—Ö —Ñ—É–Ω–∫—Ü–∏–π –Ω–∞ –¥–µ—Ä–µ–≤—å—è—Ö
—è–∑—ã–∫–æ–≤—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π expr:</p>

<figure><code>check:
  | EHole, v -> traceHole v ctx
  | e, VPre u -> begin
    match infer ctx e with
    | VKan v | VPre v -> if ieq u v then () else raise (Ineq (VPre u, VPre v))
    | t -> raise (Ineq (VPre u, t)) end
  | e, t -> eqNf (infer ctx e) t
  
conv:
  | VKan u, VKan v -> ieq u v | VPre u, VPre v -> ieq u v
  | Var (u, _), Var (v, _) -> u = v

eval:
  | EPre u -> VPre u | EKan u -> VKan u
  | EVar x -> getRho ctx x | EHole -> VHole

infer:
  | VPre n -> VPre (Z.succ n) | VKan n -> VKan (Z.succ n)
  | EPre u -> VPre (Z.succ u) | EKan u -> VKan (Z.succ u)
  | EVar x -> lookup x ctx

inferV:
  | Var (_, t) -> t | VPre n -> VPre (Z.succ n) | VKan n -> VKan (Z.succ n)

act:
  | Var (i, VI) -> actVar rho i | Var (x, t) -> Var (x, act rho t) | VHole -> VHole
  | VKan u -> VKan u | VPre u -> VPre u

check:
  | e, t -> eqNf (infer ctx e) t

and getRho ctx x = match Env.find_opt x ctx with
  | Some (_, _, Value v) -> v
  | Some (_, _, Exp e) -> eval e ctx
  | None -> raise (VariableNotFound x)

and eqNf v1 v2 : unit = traceEqNF v1 v2;
  if conv v1 v2 then () else raise (Ineq (v1, v2))

and lookup (x : name) (ctx : ctx) = match Env.find_opt x ctx with
  | Some (_, Value v, _) -> v
  | Some (_, Exp e, _) -> eval e ctx
  | None -> raise (VariableNotFound x)
</code></figure>

<p>–ó–¥–µ—Å—å –æ–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è —Ç–∞–∫ –Ω–∞–∑—ã–≤–∞–µ–º—Å—è –±–∞–∑–∞ —Ä–µ–∫—É—Ä—Å–∏–∏ –∏ —Ä–∞–±–æ—Ç–∞ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ (getRho, lookup).</p>

        <h4>Œ†-—Ç–∏–ø</h4>

  <p>–ü–µ—Ä–≤—ã–º –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø—Ä—É–≤–µ—Ä–æ–º –≤–æ–æ–±—â–µ –∏ –ø–µ—Ä–≤—ã–º –ø—Ä—É–≤–µ—Ä–æ–º –Ω–∞ —Ñ–∏–±—Ä–∞—Ü–∏–æ–Ω–Ω–æ–º —Ç–∏–ø–µ —Å—á–∏—Ç–∞–µ—Ç—Å—è AUTOMATH –¥–µ –ë—Ä–µ–π–Ω–∞.
     –ü–µ—Ä–≤–∞—è –ø–æ–ª–Ω–∞—è —Ñ–æ—Ä–º–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ CoC –∏ –ª—è–º–±–¥–∞-–∫—É–± –±—ã–ª–∏ –¥–µ—Ç–∞–ª—å–Ω–æ —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω—ã –ë–∞—Ä–µ–Ω–¥—Ä–µ—Ö—Ç–æ–º. –û–¥–Ω–∞–∫–æ –æ—Ç—Ü–æ–º
     —Ñ–æ—Ä–º–∞–ª—å–Ω–æ–π –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏ –ø—Ä–∏–Ω—è—Ç–æ —Å—á–∏—Ç–∞—Ç—å –ú–∞—Ä—Ç–∏–Ω–∞-–õ—ë—Ñ–∞. –ï–≥–æ —Ç–∏–ø–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –¥–æ —Å–∏—Ö –ø–æ—Ä —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—É—é
     –æ—Å–Ω–æ–≤—É —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø—Ä—É–≤–µ—Ä–æ–≤. –¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ MLTT —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ Œ†, Œ£, 0, 1, 2, W, Id —Ç–∏–ø–æ–≤.
     –ü—Ä–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ Anders –º—ã —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ–≤–∞–ª–∏—Å—å –º–æ—Ç–∏–≤–∞—Ü–∏–µ–π –º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç–∏ –ø–æ—ç—Ç–æ–º—É –æ—Ç–±—Ä–æ—Å–∏–ª–∏
     –≤–∞—Ä–∏–∞–Ω—Ç –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏–∏ –æ–±—â–µ–π —Å—Ö–µ–º—ã –∏–Ω–¥—É–∫—Ç–∏–≤–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∏ –≤—ã—Å—à–∏—Ö –∏–¥—É–∫—Ç–∏–≤–Ω—ã—Ö —Ç–∏–ø–æ–≤ (HIT),
     –∞ —Ä–µ—à–∏–ª–∏ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∏–Ω–¥—É–∫—Ç–∏–≤–Ω–æ–≥–æ —è–¥—Ä–∞ –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–µ W-—Ç–∏–ø—ã —Å–∏—Å—Ç–µ–º—ã MLTT.
  </div>
  </p>

<figure><code>eval:
  | EPi (a, (p, b)) -> let t = eval a ctx in VPi (t, (fresh p, closByVal ctx p t b))
  | ELam (a, (p, b)) -> let t = eval a ctx in VLam (t, (fresh p, closByVal ctx p t b))
  | EApp (f, x) -> app (eval f ctx, eval x ctx)

infer:
  | EPi (a, (p, b)) -> inferTele ctx p a b

inferV:
  | VPi (t, (x, f)) -> imax (inferV t) (inferV (f (Var (x, t))))
  | VLam (t, (x, f)) -> VPi (t, (x, fun x -> inferV (f x)))
  | VApp (f, x) -> begin match inferV f with
    | VPi (_, (_, g)) -> g x
    | v -> raise (ExpectedPi v) end

act:
  | VLam (t, (x, g)) -> VLam (act rho t, (x, g >> act rho))
  | VPi (t, (x, g)) -> VPi (act rho t, (x, g >> act rho))
  | VApp (f, x) -> app (act rho f, act rho x)

app:
  | f, x -> VApp (f, x)

conv:
  | VPi (a,(p,f)), VPi (b,(_,g)) -> let x = Var (p,a) in conv a b && conv (f x) (g x)
  | VLam (a,(p,f)), VLam (b,(_,g))
  | VApp (f,a), VApp (g,b) -> conv f g && conv a b
  
check:
  | ELam (a, (p, b)), VPi (t, (_, g)) ->
    ignore (extSet (infer ctx a)); eqNf (eval a ctx) t;
    let x = Var (p, t) in let ctx' = upLocal ctx p t x in check ctx' b (g x)

and inferTele ctx p a b =
    ignore (extSet (infer ctx a));
    let t = eval a ctx in let x = Var (p, t) in
    let ctx' = upLocal ctx p t x in
    let v = infer ctx' b in imax (infer ctx a) v
  
and inferLam ctx p a e =
    ignore (extSet (infer ctx a)); let t = eval a ctx in
    ignore (infer (upLocal ctx p t (Var (p, t))) e);
    VPi (t, (p, fun x -> inferV (eval e (upLocal ctx p t x))))
    
</code></figure>

<p>Œ†-—Ç–∏–ø —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç—Å—è –∏–Ω—Ç–µ—Ä–Ω–∞–ª–∏–∑–∞—Ü–∏–µ–π, –∞ –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –≥–æ–º–æ—Ç–æ–ø–∏—á–µ—Å–∫–æ–≥–æ
   —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ –µ—â–µ –∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π —ç–∫—Å—Ç–µ–Ω—Å–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å—é.</p>

<figure><code>
def Pi (A : U) (B : A ‚Üí U) : U := Œ† (x : A), B x
def lambda (A: U) (B: A ‚Üí U) (b: Pi A B) : Pi A B := Œª (x : A), b x
def lam (A B: U) (f: A ‚Üí B) : A ‚Üí B := Œª (x : A), f x
def apply (A: U) (B: A ‚Üí U) (f: Pi A B) (a: A) : B a := f a
def app (A B: U) (f: A ‚Üí B) (x: A): B := f x

def Œ†-Œ≤ (A : U) (B : A ‚Üí U) (a : A) (f : Pi A B)
  : Path (B a) (apply A B (lambda A B f) a) (f a) := idp (B a) (f a)
def Œ†-Œ∑ (A : U) (B : A ‚Üí U) (a : A) (f : Pi A B)
  : Path (Pi A B) f (Œª (x : A), f x) := idp (Pi A B) f

def funext-form (A B: U) (f g: A ‚Üí B): U := Path (A ‚Üí B) f g
def funext (A B: U) (f g: A ‚Üí B) (p: Œ† (x: A), Path B (f x) (g x))
  : funext-form A B f g := &lt;i> Œª (a: A), p a @ i

def happly (A B: U) (f g : A ‚Üí B) (p: funext-form A B f g) (x : A)
  : Path B (f x) (g x) := cong (A ‚Üí B) B (Œª (h: A ‚Üí B), app A B h x) f g p

def funext-Œ≤ (A B: U) (f g: A ‚Üí B) (p: Œ† (x: A), Path B (f x) (g x))
  : Œ† (x: A), Path B (f x) (g x) := Œª (x: A), happly A B f g (funext A B f g p) x

def funext-Œ∑ (A B: U) (f g: A ‚Üí B) (p: Path (A ‚Üí B) f g)
  : Path (Path (A ‚Üí B) f g) (funext A B f g (happly A B f g p)) p
 := idp (Path (A ‚Üí B) f g) p
</code></figure>

<h4>Œ£-—Ç–∏–ø</h4>

<p>–ö–∞–∫ –≤—ã —É–∂–µ –º–æ–≥–ª–∏ –∑–∞–º–µ—Ç–∏—Ç—å —Å–∏—Å—Ç–µ–º–∞ —Ç–∏–ø–æ–≤ –ø—Ä—É–≤–µ—Ä–∞ –ø–æ—Ä–µ–∑–∞–Ω–∞ –Ω–∞ –º–æ–¥—É–ª–∏,
   –∫–∞–∂–¥—ã–π –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö —Ä–µ–∞–ª–∏–∑—É–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–∏–ø —Å–∏—Å—Ç–µ–º—ã —Ç–∏–ø–æ–≤, –∞ –∏–º–µ–Ω–Ω–æ 5 –ø—Ä–∞–≤–∏–ª
   –ú–∞—Ä—Ç–∏–Ω–∞-–õ—ë—Ñ–∞: 1) –ü—Ä–∞–≤–∏–ª–æ —Å–∏–≥–Ω–∞—Ç—É—Ä—ã –∏–ª–∏ —Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ—Å–µ–ª—è—é—â–µ–µ —Ç–∏–ø –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—É—é –≤—Å–µ–ª–µ–Ω–Ω—É—é,
   2) –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã —Å –ø–æ–º–æ—â—å—é –∫–æ—Ç–æ—Ä—ã—Ö —Å–æ–∑–¥–∞—é—Ç—Å—è —ç–ª–µ–º–µ–Ω—Ç—ã —Ç–∏–ø–∞,
   3) –≠–ª–∏–º–∏–Ω–∞—Ç–æ—Ä—ã –∏/–∏–ª–∏ –ò–Ω–¥—É–∫—Ç–æ—Ä—ã —Å –ø–æ–º–æ—â—å—é –∫–æ—Ç–æ—Ä—ã—Ö –¥–æ–∫–∞–∑—ã–≤–∞—é—Ç —Ç–µ–æ—Ä–µ–º—ã –æ —Ç–∏–ø–µ,
   4) –í—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω–æ–µ —É—Ä–∞–≤–Ω–µ–Ω–∏–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—â–∏–µ –ø—Ä–æ—Ü–µ—Å –≤—ã—á–∏—Å–ª–µ–Ω–∏–π (–±–µ—Ç–∞-–ø—Ä–∞–≤–∏–ª–æ),
   5) –£—Ä–∞–≤–Ω–µ–Ω–∏–µ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏, –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—â–µ–µ –æ–±—Ä–∞—Ç–Ω—ã–π –ø—Ä–æ—Ü–µ—Å –≤—ã—á–∏—Å–ª–µ–Ω–∏–π (—ç—Ç–∞-–ø—Ä–∞–≤–∏–ª–æ). </p>

<p>–ü—Ä–∏ —ç—Ç–æ–º –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–∏–ø–∞ –≤ —Å–∏—Å—Ç–µ–º—É –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —É—Ä–∞–≤–Ω–µ–Ω–∏—è
   –ø–∞—Ç—Ç–µ—Ä–Ω-–º–∞—á–∏–Ω–≥–∞ –≤ –Ω–∞–±–æ—Ä —Ñ—É–Ω–∫—Ü–∏–π –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö —Å–æ—Å—Ç–æ–∏—Ç —Ç–∞–π–ø —á–µ–∫–µ—Ä:
   <b>infer</b>, <b>inferV</b>, <b>app</b>, <b>check</b>,
   <b>act</b>, <b>conv</b>, <b>eval</b>.
</p>

<figure><code>
infer:
  | ESig (a, (p, b)) -> inferTele ctx p a b
  | EFst e -> fst (extSigG (infer ctx e))
  | ESnd e -> let (_, (_, g)) = extSigG (infer ctx e) in g (vfst (eval e ctx))
  | EField (e, p) -> inferField ctx p e

inferV:
  | VFst e -> fst (extSigG (inferV e))
  | VSnd e -> let (_, (_, g)) = extSigG (inferV e) in g (vfst e)

eval:
  | ESig (a, (p, b)) -> let t = eval a ctx in VSig (t, (fresh p, closByVal ctx p t b))
  | EPair (r, e1, e2) -> VPair (r, eval e1 ctx, eval e2 ctx)
  | EFst e -> vfst (eval e ctx)
  | EField (e, p) -> evalField p (eval e ctx)

check:
  | EPair (r, e1, e2), VSig (t, (p, g)) ->
    ignore (extSet (inferV t)); check ctx e1 t;
    check ctx e2 (g (eval e1 ctx)); begin match p with
    | Name (v, _) -> r := Some v
    | Irrefutable -> () end

act:
  | VSig (t, (x, g)) -> VSig (act rho t, (x, g >> act rho))
  | VPair (r, u, v) -> VPair (r, act rho u, act rho v)
  | VFst k -> vfst (act rho k) | VSnd k -> vsnd (act rho k)

conv:
  | VFst x, VFst y | VSnd x, VSnd y -> conv x y
  | VPair (_, a, b), VPair (_, c, d) -> conv a c && conv b d
  | VPair (_, a, b), v | v, VPair (_, a, b) -> conv (vfst v) a && conv (vsnd v) b

and inferField ctx p e = snd (getField p (eval e ctx) (infer ctx e))

let rec getField p v = function
  | VSig (t, (q, g)) ->
    if matchIdent p q then (vfst v, t)
    else getField p (vsnd v) (g (vfst v))
  | t -> raise (ExpectedSig t)

let vfst : value -> value = function
  | VPair (_, u, _) -> u
  | v -> VFst v

let vsnd : value -> value = function
  | VPair (_, _, u) -> u
  | v -> VSnd v
</code></figure>

<p>–ù–∞—à Œ£-—Ç–∏–ø —Ä–∞—Å—à–∏—Ä–µ–Ω –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º —ç–ª–∏–º–∏–Ω–∞—Ç–æ—Ä–æ–º –∫–æ—Ç–æ—Ä—ã–π –¥–∞–µ—Ç –¥–æ—Å—Ç—É–ø –∫ –∏–º–µ–Ω–æ–≤–∞–Ω–æ–º—É
   —Ç–µ–ª–µ—Å–∫–æ–º—É –ø—Ä—è–º–æ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏. –≠—Ç–æ—Ç –º–µ—Ö–∞–Ω–∏–∑–º –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å
   –±–∞–∑–æ–≤—ã–π –º–µ—Ö–∞–Ω–∏–∑–º –∑–∞–ø–∏—Å–µ–π-–∫–æ—Ä—Ç–µ–∂–µ–π —Å –∏–º–µ–Ω–æ–≤–∞–Ω—ã–º–∏ –ø–æ–ª—è–º–∏,
   –∑–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ–º –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π —Ä–µ–∫–æ—Ä–¥–æ–≤. –≠–ª–∏–º–∏–Ω–∞—Ç–æ—Ä—ã .1 –∏ .2 (–∏–∑ cubicaltt) —Ç–æ–∂–µ —Ä–∞–±–æ—Ç–∞—é—Ç.
</p>

<figure><code>def Sigma (A : U) (B : A ‚Üí U) : U := summa (x: A), B x
def prod (A B : U) : U := summa (_ : A), B
def pair (A: U) (B: A ‚Üí U) (a: A) (b: B a) : Sigma A B ‚âî (a, b)
def pr‚ÇÅ (A: U) (B: A ‚Üí U) (x: Sigma A B) : A ‚âî x.1
def pr‚ÇÇ (A: U) (B: A ‚Üí U) (x: Sigma A B) : B (pr‚ÇÅ A B x) ‚âî x.2
  
def Sigma-rec (A: U) (B: A -> U) (C: U) (g: Œ† (x: A), B(x) -> C)
    (p: Œ£ (x: A), B x): C := g p.1 p.2
  
def Sigma-ind (A : U) (B : A -> U) (C : Œ† (s: Œ£ (x: A), B x), U) 
    (g: Œ† (x: A) (y: B x), C (x,y)) (p: Œ£ (x: A), B x) : C p := g p.1 p.2
  
def ac (A B: U) (R: A -> B -> U) (g: Œ† (x: A), Œ£ (y: B), R x y)
  : Œ£ (f: A -> B), Œ† (x: A), R x (f x) := (\(i:A),(g i).1,\(j:A),(g j).2)
  
def total (A:U) (B C : A -> U) (f : Œ† (x:A), B x -> C x) (w: Œ£(x: A), B x)
  : Œ£(x: A), C x := (w.1,f (w.1) (w.2))
  
def funDepTr (A: U) (P: A -> U) (a0 a1: A) (p: PathP (&lt;_>A) a0 a1)
    (u0: P a0) (u1: P a1)
  : PathP (&lt;_>U) (PathP (&lt;i> P (p @ i)) u0 u1) (PathP (&lt;_>P a1)
            (hcomp (P a1) 0 (Œª (k : I), []) (transp (&lt;i> P (p @ i)) 0 u0)) u1)
 := &lt;j> PathP (&lt;i> P (p @ j \/ i))
            (comp (\(i:I), P (p @ j /\ i)) -j (\(k: I), [(j = 0) -> u0 ])
            (inc (P a0) -j u0)) u1
  
def pathSig0 (A: U) (P: A -> U) (t u: Œ£ (x: A), P x) (p: PathP (&lt;_>A) t.1 u.1)
  : PathP (&lt;_>U) (PathP (&lt;i>P (p @ i)) t.2 u.2) (PathP (&lt;_>P u.1)
          (hcomp (P u.1) 0 (Œª(k:I),[]) (transp (&lt;i> P (p @ i)) 0 t.2)) u.2)
 := funDepTr A P t.1 u.1 p t.2 u.2</code></figure>

<h4>0-—Ç–∏–ø</h4>

<p>0-—Ç–∏–ø –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Ç–∏–ø-–ª–æ–∂—å, –ª–æ–≥–∏—á–µ—Å–∫–∏–π –Ω–æ–ª—å ùüé, –ø—É—Å—Ç–æ—Ç—É, Empty, Void –∏–ª–∏ ‚ä•.
   –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–π, —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ –ø—Ä–∞–≤–∏–ª–∞ —Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏ –∏–Ω–¥—É–∫—Ç–æ—Ä.</p>

<figure><code>eval:
  | EEmpty -> VEmpty
  | EIndEmpty e -> VIndEmpty (eval e ctx)

inferV:
  | VEmpty -> VKan Z.zero
  | VIndEmpty t -> implv VEmpty t

act:
  | VEmpty -> VEmpty
  | VIndEmpty v -> VIndEmpty (act rho v)

conv:
  | VEmpty, VEmpty -> true
  | VIndEmpty u, VIndEmpty v -> conv u v

infer:
  | EEmpty | EUnit
  | EIndEmpty e -> ignore (extSet (infer ctx e)); implv VEmpty (eval e ctx)
</code></figure>

<h4>1-—Ç–∏–ø</h4>

<p>1-—Ç–∏–ø –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –ª–æ–≥–∏—á–µ—Å–∫—É—é –µ–¥–∏–Ω–∏—Ü—É ùüè, —Ç–∏–ø-–∏—Å—Ç–∏–Ω—É –≤ –∏–Ω—Ç—É–∏—Ü–∏–æ–Ω–∏—Å—Ç—Å–∫–æ–π
   –ø—Ä–æ–ø–æ–∑–∏—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ª–æ–≥–∏–∫–µ, Unit –∏–ª–∏ ‚ä§. –ò–º–µ–µ—Ç –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä ‚òÖ.</p>

<figure><code>eval:
  | EUnit -> VUnit
  | EStar -> VStar
  | EIndUnit e -> VIndUnit (eval e ctx)

app:
  | VApp (VIndUnit _, x), VStar -> x

inferV:
  | VUnit -> VKan Z.zero
  | VStar -> VUnit
  | VIndUnit t -> recUnit t

act:
  | VUnit -> VUnit
  | VStar -> VStar
  | VIndUnit v -> VIndUnit (act rho v)

conv:
  | VUnit, VUnit -> true
  | VStar, VStar -> true
  | VIndUnit u, VIndUnit v -> conv u v

infer:
  | EStar -> VUnit
  | EIndUnit e -> inferInd false ctx VUnit e recUnit

and recUnit t = let x = freshName "x" in
  implv (app (t, VStar)) (VPi (VUnit, (x, fun x -> app (t, x))))
</code></figure>

<h4>2-—Ç–∏–ø</h4>

<p>2-—Ç–∏–ø –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –ª–æ–≥–∏—á–µ—Å–∫—É—é –¥–≤–æ–π–∫—É ùüê, –±—É–ª–µ–≤—ã–π —Ç–∏–ø Bool –∏–ª–∏ 0-–º–µ—Ä–Ω—É—é –≥–æ–º–æ—Ç–æ–ø–∏—á–µ—Å–∫—É—é —Å—Ñ–µ—Ä—É.
   –ò–º–µ–µ—Ç –¥–≤–∞ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞ false=0‚ÇÇ –∏ true=1‚ÇÇ.</p>

<figure><code>eval:
  | EBool -> VBool
  | EFalse -> VFalse
  | ETrue -> VTrue
  | EIndBool e -> VIndBool (eval e ctx)

app:
  | VApp (VApp (VIndBool _, a), _), VFalse -> a
  | VApp (VApp (VIndBool _, _), b), VTrue -> b

inferV:
  | VBool -> VKan Z.zero
  | VFalse | VTrue -> VBool
  | VIndBool t -> recBool t

act:
  | VBool -> VBool
  | VFalse -> VFalse
  | VTrue -> VTrue
  | VIndBool v -> VIndBool (act rho v)

conv:
  | VBool, VBool -> true
  | VFalse, VFalse -> true
  | VTrue, VTrue -> true
  | VIndBool u, VIndBool v -> conv u v

infer:
  | EBool -> VKan Z.zero
  | EFalse | ETrue -> VBool
  | EIndBool e -> inferInd false ctx VBool e recBool

and recBool t = let x = freshName "x" in
  implv (app (t, VFalse)) (implv (app (t, VTrue))
    (VPi (VBool, (x, fun x -> app (t, x)))))
</code></figure>

<h4>W-—Ç–∏–ø</h4>

<p>W-—Ç–∏–ø –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è —Ö–æ—Ä–æ—à–æ-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö –¥–µ—Ä–µ–≤—å–µ–≤. 
   W-—Ç–∏–ø –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –Ω–∞ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞—Ö –∏–Ω–¥—É–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞,
   –∞ –≤–µ—Ç–≤–∏ —É—Å–ª–æ–≤–∏—è –≤—ã—Ä–∞–∂–µ–Ω—ã —Ñ—É–Ω–∫—Ü–∏–µ–π –≤—Ç–æ—Ä–æ–π –∑–∞–≤–∏—Å–∏–º–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã. –° –ø–æ–º–æ—â—å—é
   –≥–æ–º–æ—Ç–æ–ø–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞, W-—Ç–∏–ø–æ–≤, –∞ —Ç–∞–∫–∂–µ —Ç–∏–ø–æ–≤ 0,1,2 –≤—ã—Ä–∞–∑–∏–º–∞ –∏–Ω–¥—É–∫—Ü–∏—è –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª.
</p>

<figure><code>
eval:
  | EW (a, (p, b)) -> let t = eval a ctx in W (t, (fresh p, closByVal ctx p t b))
  | ESup (a, b) -> VSup (eval a ctx, eval b ctx)
  | EIndW (a, b, c) -> VIndW (eval a ctx, eval b ctx, eval c ctx)

app: 
  | VApp (VIndW (a, b, c), g), VApp (VApp (VSup (_, _), x), f) ->
    app (app (app (g, x), f),
      VLam (app (b, x), (freshName "b", fun y ->
        app (VApp (VIndW (a, b, c), g), app (f, y)))))

inferV:
  | VSup (a, b) -> inferSup a b
  | VIndW (a, b, c) -> inferIndW a b c

and wtype a b = W (a, (freshName "x", fun x -> app (b, x)))

and inferSup a b = let t = wtype a b in let x = freshName "x" in
  VPi (a, (x, fun x -> implv (implv (app (b, x)) t) t))

and inferIndW a b c = let t = wtype a b in
  implv (VPi (a, (freshName "x", fun x ->
    VPi (implv (app (b, x)) t, (freshName "f", fun f ->
      implv (VPi (app (b, x), (freshName "b", fun b -> app (c, (app (f, b))))))
        (app (c, VApp (VApp (VSup (a, b), x), f))))))))
    (VPi (t, (freshName "w", fun w -> app (c, w))))

act:
  | W (t, (x, g)) -> W (act rho t, (x, g >> act rho))
  | VSup (a, b) -> VSup (act rho a, act rho b)
  | VIndW (a, b, c) -> VIndW (act rho a, act rho b, act rho c)

conv:
  | VSup (a1,b1), VSup (a2,b2) -> conv a1 a2 && conv b1 b2
  | VIndW (a1,b1,c1), VIndW (a2,b2,c2) -> conv a1 a2 && conv b1 b2 && conv c1 c2

infer:
  | ESup (a, b) -> let t = eval a ctx in ignore (extSet (infer ctx a));
    let (t', (p, g)) = extPiG (infer ctx b) in eqNf t t';
    ignore (extSet (g (Var (p, t))));
    inferSup t (eval b ctx)
  | EIndW (a, b, c) -> let t = eval a ctx in ignore (extSet (infer ctx a));
    let (t', (p, g)) = extPiG (infer ctx b) in
    eqNf t t'; ignore (extSet (g (Var (p, t))));
    let (w', (q, h)) = extPiG (infer ctx c) in
    eqNf (wtype t (eval b ctx)) w';
    ignore (extSet (h (Var (q, w'))));
    inferIndW t (eval b ctx) (eval c ctx)

and inferIndW a b c = let t = wtype a b in
    implv (VPi (a, (freshName "x", fun x ->
      VPi (implv (app (b, x)) t, (freshName "f", fun f ->
        implv (VPi (app (b, x), (freshName "b", fun b -> app (c, (app (f, b))))))
          (app (c, VApp (VApp (VSup (a, b), x), f))))))))
      (VPi (t, (freshName "w", fun w -> app (c, w))))

   </code></figure>

   <p>–ü–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ W —Ç–∏–ø—ã –≤ —è–¥—Ä–µ, –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø—Ä–∏–Ω—Ü–∏–ø–∞ –∏–Ω–¥—É–∫—Ü–∏–∏ –Ω–∞–º –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è
      —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç –≤ —Ñ–∏–±—Ä–∞—Ü–∏–æ–Ω–Ω–æ–º –ø—É—Ç–µ Path.</p>

<figure><code>
def ind·µÇ-Œ≤ (A : U) (B : A ‚Üí U) (C : (W (x : A), B x) ‚Üí U) (g : Œ† (x : A)
    (f : B x ‚Üí (W (x : A), B x)), (Œ† (b : B x), C (f b)) ‚Üí C (sup A B x f))
    (a : A) (f : B a ‚Üí (W (x : A), B x))
  : PathP (&lt;_> C (sup A B a f))
          (ind·µÇ A B C g (sup A B a f)) (g a f (Œª (b : B a), ind·µÇ A B C g (f b)))
 := &lt;_> g a f (Œª (b : B a), ind·µÇ A B C g (f b))

def trans-W (A : I ‚Üí U) (B : Œ† (i : I), A i ‚Üí U)
    (a : A 0) (f : B 0 a ‚Üí (W (x : A 0), B 0 x))
  : W (x : A 1), B 1 x
 := sup (A 1) (B 1) (transp (&lt;i> A i) 0 a)
        (transp (&lt;i> B i (transFill (A 0)
                (A 1) (<j> A j) a @ i) ‚Üí (W (x : A i), B i x)) 0 f)

def trans-W‚Ä≤ (A : I ‚Üí U) (B : Œ† (i : I), A i ‚Üí U)
    (a : A 0) (f : B 0 a ‚Üí (W (x : A 0), B 0 x))
  : W (x : A 1), B 1 x
 := transp (&lt;i> W (x : A i), B i x) 0 (sup (A 0) (B 0) a f)

def trans-W-is-correct (A : I ‚Üí U) (B : Œ† (i : I), A i ‚Üí U)
    (a : A 0) (f : B 0 a ‚Üí (W (x : A 0), B 0 x))
  : Path (W (x : A 1), B 1 x) (trans-W A B a f) (trans-W‚Ä≤ A B a f)
 := &lt;_> trans-W A B a f

def hcomp-W‚Ä≤ (A : U) (B : A ‚Üí U) (r : I) (a : I ‚Üí Partial A r)
    (f : Œ† (i : I), PartialP [(r = 1) ‚Üí B (a i 1=1) ‚Üí (W (x : A), B x)] r)
    (a‚ÇÄ : A[r ‚Ü¶ a 0]) (f‚ÇÄ : (B (ouc a‚ÇÄ) ‚Üí (W (x : A), B x)) [r ‚Ü¶ f 0])
  : W (x : A), B x
 := hcomp (W (x : A), B x) r
          (Œª (i : I), [(r = 1) ‚Üí sup A B (a i 1=1) (f i 1=1)])
          (sup A B (ouc a‚ÇÄ) (ouc f‚ÇÄ))

</code></figure>

<h4>Path-—Ç–∏–ø</h4>

<p>–ù–∞–∫–æ–Ω–µ—Ü –º–Ω–æ–≥–æ–º–µ—Ä–Ω—ã–π Path —Ç–∏–ø –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Ç–æ –≥–æ–º–æ—Ç–æ–ø–∏—á–µ—Å–∫–æ–µ –∫—É–±–∏—á–µ—Å–∫–æ–µ –≥–µ—Ç–µ—Ä–æ–≥–µ–Ω–Ω–æ–µ
   —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ —Å –ø–æ–º–æ—â—å—é –∫–æ—Ç–æ—Ä–æ–≥–æ –º–æ–∂–Ω–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä—É–ø–æ–∏–¥—ã (—Å–º–æ—Ç—Ä–∏—Ç–µ –±–∞–∑–æ–≤—É—é –±–∏–±–ª–∏–æ—Ç–µ–∫—É –ê–Ω–¥–µ—Ä—Å–∞).</p>

<figure><code>eval:
  | EPathP e -> VPathP (eval e ctx)
  | EPLam e -> VPLam (eval e ctx)
  
check:
  | EPLam (ELam (EI, (i, e))), VApp (VApp (VPathP p, u0), u1) ->
    let v = Var (i, VI) in let ctx' = upLocal ctx i VI v in
    let v0 = eval e (upLocal ctx i VI vzero) in
    let v1 = eval e (upLocal ctx i VI vone) in
    check ctx' e (appFormula p v); eqNf v0 u0; eqNf v1 u1

inferV:
  | VPLam (VLam (VI, (_, g))) -> let t = VLam (VI, (freshName "Œπ", g >> inferV)) in
    VApp (VApp (VPathP (VPLam t), g vzero), g vone)
  | VAppFormula (f, x)       -> let (p, _, _) = extPathP (inferV f) in appFormula p x
  | VPathP p -> let (_, _, v) = freshDim () in let t = inferV (appFormula p v) in
    let v0 = appFormula p vzero in let v1 = appFormula p vone in implv v0 (implv v1 t)

act:
  | VPLam f -> VPLam (act rho f)
  | VPathP v -> VPathP (act rho v)
  | VAppFormula (f, x)   -> appFormula (act rho f) (act rho x)

conv:
  | VPLam f, VPLam g -> conv f g
  | VPLam f, v | v, VPLam f ->
    let (_, _, i) = freshDim () in conv (appFormula v i) (app (f, i))
  | VPathP a, VPathP b -> conv a b

infer:
  | EPathP p -> inferPath ctx p
  | EPLam (ELam (EI, (i, e))) ->
    let ctx' = upLocal ctx i VI (Var (i, VI)) in ignore (infer ctx' e);
    let g = fun j -> eval e (upLocal ctx i VI j) in
    let t = VLam (VI, (freshName "Œπ", g >> inferV)) in
    VApp (VApp (VPathP (VPLam t), g vzero), g vone)
  | EPLam _ -> raise (InferError e)
  | VAppFormula (f, x), VAppFormula (g, y) -> conv f g && conv x y

and inferPath ctx p =
  let (_, t0, t1) = extPathP (infer ctx p) in
  let k = extSet (inferV t0) in implv t0 (implv t1 (VKan k))

and appFormula v x = match v with
  | VPLam f -> app (f, x)
  | _       -> let (_, u0, u1) = extPathP (inferV v) in
    begin match x with
      | VDir Zero -> u0
      | VDir One  -> u1
      | i -> VAppFormula (v, i)
    end
</code></figure>

<p>–ò–º–µ—è Œ†,Œ£ –∏ Path —Ç–∏–ø—ã –∞ —Ç–∞–∫–∂–µ —É—Ä–µ–∑–∞–Ω–Ω—ã–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç –º–æ–∂–Ω–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å
   –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—É—é —Å–µ–º–∞–Ω—Ç–∏–∫—É MLTT-73:</p>

<figure><code>def MLTT (A : U) : U‚ÇÅ ‚âî Œ£
  (Œ†-form  : Œ† (B: A ‚Üí U), U)
  (Œ†-ctor‚ÇÅ : Œ† (B: A ‚Üí U), Pi A B ‚Üí Pi A B)
  (Œ†-elim‚ÇÅ : Œ† (B: A ‚Üí U), Pi A B ‚Üí Pi A B)
  (Œ†-comp‚ÇÅ : Œ† (B: A ‚Üí U) (a: A) (f: Pi A B),
               Equ (B a) (Œ†-elim‚ÇÅ B (Œ†-ctor‚ÇÅ B f) a) (f a))
  (Œ†-comp‚ÇÇ : Œ† (B : A ‚Üí U) (a : A) (f : Pi A B),
               Equ (Pi A B) f (Œª (x : A), f x))
  (Œ£-form  : Œ† (B: A ‚Üí U), U)
  (Œ£-ctor‚ÇÅ : Œ† (B: A ‚Üí U) (a: A) (b : B a) , Sigma A B)
  (Œ£-elim‚ÇÅ : Œ† (B: A ‚Üí U) (p: Sigma A B), A)
  (Œ£-elim‚ÇÇ : Œ† (B: A ‚Üí U) (p: Sigma A B), B (pr‚ÇÅ A B p))
  (Œ£-comp‚ÇÅ : Œ† (B: A ‚Üí U) (a: A) (b: B a), Equ A a (Œ£-elim‚ÇÅ B (Œ£-ctor‚ÇÅ B a b)))
  (Œ£-comp‚ÇÇ : Œ† (B: A ‚Üí U) (a: A) (b: B a), Equ (B a) b (Œ£-elim‚ÇÇ B (a, b)))
  (Œ£-comp‚ÇÉ : Œ† (B: A ‚Üí U) (p: Sigma A B), Equ (Sigma A B) p (pr‚ÇÅ A B p, pr‚ÇÇ A B p))
  (=-form  : Œ† (a: A), A ‚Üí U)
  (=-ctor‚ÇÅ : Œ† (a: A), Equ A a a)
  (=-elim‚ÇÅ : Œ† (a: A) (C: D A) (d: C a a (=-ctor‚ÇÅ a)) (y: A) (p: Equ A a y), C a y p)
  (=-comp‚ÇÅ : Œ† (a: A) (C: D A) (d: C a a (=-ctor‚ÇÅ a)),
     Equ (C a a (=-ctor‚ÇÅ a)) d (=-elim‚ÇÅ a C d a (=-ctor‚ÇÅ a))), ùüè

theorem internalizing (A : U) : MLTT A ‚âî
  (Pi A, lambda A, app A, comp‚ÇÅ A, comp‚ÇÇ A,
   Sigma A, pair A, pr‚ÇÅ A, pr‚ÇÇ A, comp‚ÇÉ A, comp‚ÇÑ A, comp‚ÇÖ A,
   Equ A, refl A, J A, comp‚ÇÜ A, A)
</code></figure>

<p>–ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —ç—Ç–∏ —Ç–µ—Ä–º—ã –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Å–∞–º–æ–ø—Ä–æ–≤–µ—Ä–∫–∏ (reality check).</p>

<figure><code>
def Path (A : U) (x y : A) : U := PathP (&lt;_> A) x y
def idp (A : U) (x : A) : Path A x x := &lt;_> x
def singl (A: U) (a: A): U := Œ£ (x: A), Path A a x
def eta (A: U) (a: A): singl A a := (a, idp A a)
def sym (A: U) (a b : A) (p : Path A a b) : Path A b a := &lt;i> p @ -i
def contr (A : U) (a b : A) (p : Path A a b)
  : Path (singl A a) (eta A a) (b, p) := &lt;i> (p @ i, &lt;j> p @ i /\ j)

def isContr (A: U) : U := Œ£ (x: A), Œ† (y: A), Path A x y
def isContrSingl (A : U) (a : A) : isContr (singl A a)
 := ((a,idp A a),(\ (z:singl A a), contr A a z.1 z.2))

def cong (A B : U) (f : A ‚Üí B) (a b : A) (p : Path A a b)
  : Path B (f a) (f b) := &lt;i> f (p @ i)

def ap (A: U) (a x: A) (B: A ‚Üí U) (f: A ‚Üí B a) (b: B a) (p: Path A a x)
  : Path (B a) (f a) (f x) := &lt;i> f (p @ i)

def inv (A: U) (a b: A) (p: Path A a b): Path A b a := &lt;i> p @ -i
def Path-Œ∑ (A : U) (x y : A) (p : Path A x y)
  : Path (Path A x y) p (&lt;i> p @ i) := &lt;_> p

def idp-left (A : U) (x y : A) (p : Path A x y)
  : Path (Path A x x) (&lt;_> x) (&lt;_> p @ 0) := &lt;_ _> x

def idp-right (A : U) (x y : A) (p : Path A x y)
  : Path (Path A y y) (&lt;_> y) (&lt;_> p @ 1) := &lt;_ _> y

def sym-sym-eq-idp (A : U) (x y : A) (p : Path A x y)
  : Path (Path A x y) p (sym A y x (sym A x y p)) := &lt;_> p

def section (A B : U) (f : A -> B) (g : B -> A) : U
 := Œ† (b : B), Path B (f (g b)) b

def retract (A B : U) (f : A -> B) (g : B -> A) : U
 := Œ† (a : A), Path A (g (f a)) a

def hmtpy (A : U) (x y : A) (p : Path A x y)
  : Path (Path A x x) (&lt;_> x) (&lt;i> p @ i /\ -i) := <j i> p @ j /\ i /\ -i

def plam (A : U) (f : I ‚Üí A) : Path A (f 0) (f 1) := &lt;i> f i
def elim (A : U) (a b : A) (p : Path A a b) : I ‚Üí A := Œª (i : I), p @ i
def plam-elim (A : U) (f : I ‚Üí A)
  : Id (I ‚Üí A) (elim A (f 0) (f 1) (plam A f)) f := ref f

def elim-plam (A : U) (a b : A) (p : Path A a b)
  : Path (Path A a b) (plam A (elim A a b p)) p := &lt;_> p

def isProp (A : U) : U := Œ† (a b : A), Path A a b
def isSet (A : U) : U := Œ† (a b : A) (a0 b0 : Path A a b), Path (Path A a b) a0 b0
def isGroupoid (A : U) : U := Œ† (a b : A) (x y : Path A a b)
      (i j : Path (Path A a b) x y), Path (Path (Path A a b) x y) i j

def SET : U‚ÇÅ := Œ£ (X : U), isSet X

def transport (A B: U) (p : PathP (&lt;_> U) A B) (a: A): B := transp p 0 a
def trans_comp (A : U) (a : A) : Path A a (transport A A (&lt;i> A) a)
 := &lt;j> transp (&lt;_> A) -j a
def subst (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a)
  : P b := transp (&lt;i> P (p @ i)) 0 e
def D (A : U) : U‚ÇÅ ‚âî Œ† (x y : A), Path A x y ‚Üí U
def J (A: U) (x: A) (C: D A) (d: C x x (idp A x)) (y: A) (p: Path A x y) : C x y p
 := subst (singl A x) (\ (z: singl A x), C x (z.1) (z.2))
          (eta A x) (y, p) (contr A x y p) d
  
def subst_comp (A: U) (P: A ‚Üí U) (a: A) (e: P a)
  : Path (P a) e (subst A P a a (idp A a) e) := trans_comp (P a) e

def J-Œ≤ (A : U) (a : A) (C : D A) (d: C a a (idp A a))
  : Path (C a a (idp A a)) d (J A a C d a (idp A a))
 := subst_comp (singl A a) (\ (z: singl A a), C a (z.1) (z.2)) (eta A a) d

</code></figure>

<p>–ê —Ç–∞–∫–∂–µ –∫–∞—Ç–µ–≥–æ—Ä–Ω–∞—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –≥—Ä—É–ø–æ–∏–¥–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö
–≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—ã—Ö —Å–≤–æ–π—Å—Ç–≤ –≥–æ–º–æ—Ç–æ–ø–∏—á–µ—Å–∫–æ–≥–æ –ø—É—Ç–∏.</p>

<figure><code>def isCatGroupoid (C: cat): U := Œ£
  (id: Œ† (x: C.ob), C.hom x x)
  (c: Œ† (x y z:C.ob), C.hom x y -> C.hom y z -> C.hom x z)
  (HomSet: Œ† (x y: C.ob), isSet (C.hom x y))
  (inv: Œ† (x y: C.ob), C.hom x y -> C.hom y x)
  (inv-left: Œ†(x y: C.ob) (p: C.hom x y),
      Path (C.hom x x)(c x y x p (inv x y p))(id x))
  (inv-right: Œ†(x y: C.ob) (p: C.hom x y),
      Path (C.hom y y)(c y x y (inv x y p) p)(id y))
  (left: Œ† (x y: C.ob) (f: C.hom x y), Path (C.hom x y) f (c x x y (id x) f))
  (right: Œ† (x y: C.ob) (f: C.hom x y), Path (C.hom x y) f (c x y y f (id y)))
  (assoc: Œ† (x y z w: C.ob) (f: C.hom x y) (g: C.hom y z) (h: C.hom z w),
    Path (C.hom x w) (c x z w (c x y z f g) h) (c x y w f (c y z w g h))), ùüè

def CatGroupoid (X : U) (G : isGroupoid X)
  : isCatGroupoid (PathCat X)
 := ( idp X,
      comp-Path X,
      G,
      sym X,
      comp-inv-Path‚Åª¬π X,
      comp-inv-Path X,
      comp-Path-left X,
      comp-Path-right X,
      comp-Path-assoc X,
      ‚òÖ
    )</code></figure>

<h4>‚Ñï-—Ç–∏–ø</h4>

<p>–¢–∏–ø –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª –≤—ã–≤–æ–¥–∏–º –≤ –Ω–∞—à–µ–π —Å–∏—Å—Ç–µ–º–µ</p>

<figure><code>def ‚Ñï := W (x : ùüê), ind‚ÇÇ (Œª (_ : ùüê), U) ùüé ùüè x
def ‚Ñï-ctor := ind‚ÇÇ (Œª (_ : ùüê), U) ùüé ùüè
def zero : ‚Ñï := sup ùüê ‚Ñï-ctor 0‚ÇÇ (ind‚ÇÄ ‚Ñï)
def succ (n : ‚Ñï) : ‚Ñï := sup ùüê ‚Ñï-ctor 1‚ÇÇ (Œª (x : ùüè), n)
  
def ùüé‚ü∂‚Ñï (C : ‚Ñï ‚Üí U) (f : ùüé ‚Üí ‚Ñï) : C zero ‚Üí C (sup ùüê ‚Ñï-ctor 0‚ÇÇ f)
 := transp (&lt;i> C (sup ùüê ‚Ñï-ctor 0‚ÇÇ
        (Œª (x : ùüé), ind‚ÇÄ (PathP (&lt;_> ‚Ñï) (ind‚ÇÄ ‚Ñï x) (f x)) x @ i))) 0
  
def ùüè‚ü∂‚Ñï (C : ‚Ñï ‚Üí U) (f : ùüè ‚Üí ‚Ñï) : C (succ (f ‚òÖ)) ‚Üí C (sup ùüê ‚Ñï-ctor 1‚ÇÇ f)
 := transp (&lt;i> C (sup ùüê ‚Ñï-ctor 1‚ÇÇ
        (Œª (x : ùüè), ind‚ÇÅ (Œª (y : ùüè), PathP (&lt;_> ‚Ñï) (f ‚òÖ) (f y))
                (&lt;_> f ‚òÖ) x @ i))) 0
  
def ‚Ñï-ind (C : ‚Ñï ‚Üí U) (z : C zero) (s : Œ† (n : ‚Ñï), C n ‚Üí C (succ n))
  : Œ† (n : ‚Ñï), C n
 := ind·µÇ ùüê ‚Ñï-ctor C
    (ind‚ÇÇ (Œª (x : ùüê), Œ† (f : ‚Ñï-ctor x ‚Üí ‚Ñï),
             (Œ† (b : ‚Ñï-ctor x), C (f b)) ‚Üí C (sup ùüê ‚Ñï-ctor x f))
          (Œª (f : ùüé ‚Üí ‚Ñï) (g : Œ† (x : ùüé), C (f x)), ùüé‚ü∂‚Ñï C f z)
          (Œª (f : ùüè ‚Üí ‚Ñï) (g : Œ† (x : ùüè), C (f x)), ùüè‚ü∂‚Ñï C f (s (f ‚òÖ) (g ‚òÖ))))
  
def ‚Ñï-rec (C : U) (z : C) (s : ‚Ñï ‚Üí C ‚Üí C) : ‚Ñï ‚Üí C := ‚Ñï-ind (Œª (_ : ‚Ñï), C) z s
def ‚Ñï-iter (C : U) (z : C) (s : C ‚Üí C) : ‚Ñï ‚Üí C := ‚Ñï-rec C z (Œª (_ : ‚Ñï), s)
def ‚Ñï-case (C : U) (z s : C) : ‚Ñï ‚Üí C := ‚Ñï-iter C z (Œª (_ : C), s)
  
def plus : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
 := ‚Ñï-iter (‚Ñï ‚Üí ‚Ñï) (idfun ‚Ñï) (‚àò ‚Ñï ‚Ñï ‚Ñï succ)

def mult : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
 := ‚Ñï-rec (‚Ñï ‚Üí ‚Ñï) (\(_: ‚Ñï), zero) (\(_: ‚Ñï) (x: ‚Ñï ‚Üí ‚Ñï) (m: ‚Ñï), plus m (x m))
</code></figure>

<h4>+ —Ç–∏–ø</h4>

<p>–û–ø–µ—Ä–∞—Ü–∏—è –ª–æ–≥–∏—á–µ—Å–∫–æ–≥–æ –∏–ª–∏ –≤ IPL –≤—ã–≤–æ–¥–∏–º–∞ –≤ –Ω–∞—à–µ–π —Å–∏—Å—Ç–µ–º–µ</p>

<figure><code>def + (A B: U) : U := Œ£ (x : ùüê), ind‚ÇÇ (Œª (_ : ùüê), U) A B x
def inl (A B : U) (a : A) : + A B := (0‚ÇÇ, a)
def inr (A B : U) (b : B) : + A B := (1‚ÇÇ, b)
def +-ind (A B : U) (C : + A B ‚Üí U) (f : Œ† (x : A), C (inl A B x))
    (g : Œ† (y : B), C (inr A B y)) (w : + A B) : C w
 := ind‚ÇÇ (Œª (x : ùüê), Œ† (u : ind‚ÇÇ (Œª (_ : ùüê), U) A B x), C (x, u)) f g w.1 w.2
</code></figure>

<h4>Maybe-—Ç–∏–ø</h4>

<p>Maybe-—Ç–∏–ø –≤—ã–≤–æ–¥–∏–º –≤ –Ω–∞—à–µ–π —Å–∏—Å—Ç–µ–º–µ</p>

<figure><code>def maybe (A : U) : U := + ùüè A
def nothing (A : U) : maybe A := (0‚ÇÇ, ‚òÖ)
def just (A : U) (a : A) : maybe A := (1‚ÇÇ, a)
def maybe-ind (A : U) (P: maybe A -> U) (n: P (nothing A))
    (j: Œ† (x: A), P (just A x)) : Œ† (a: maybe A), P a
 := +-ind ùüè A P (ind‚ÇÅ (Œª (x : ùüè), P (0‚ÇÇ, x)) n) j
</code></figure>

<h4>Fin-—Ç–∏–ø</h4>

<p>–¢–∏–ø –∫–æ–Ω–µ—á–Ω—ã—Ö –º–Ω–æ–∂–µ—Å—Ç–≤ –≤—ã–≤–æ–¥–∏–º –≤ –Ω–∞—à–µ–π —Å–∏—Å—Ç–µ–º–µ:</p>

<figure><code>def Fin : ‚Ñï ‚Üí U := ‚Ñï-iter U ùüé (+ ùüè)
def fzero (n : ‚Ñï) : Fin (succ n) := (0‚ÇÇ, ‚òÖ)
def fsucc (n : ‚Ñï) (m : Fin n) : Fin (succ n) := (1‚ÇÇ, m)
def Fin-ind (T : Œ† (n : ‚Ñï), Fin n ‚Üí U) (z : Œ† (n : ‚Ñï), T (succ n) (fzero n))
    (s: Œ† (n: ‚Ñï) (x: Fin n), T n x ‚Üí T (succ n) (fsucc n x)) (m: ‚Ñï) (x: Fin m)
  : T m x
 := ‚Ñï-ind (Œª (k : ‚Ñï), Œ† (x : Fin k), T k x)
          (Œª (x : ùüé), ind‚ÇÄ (T zero x) x)
          (Œª (k : ‚Ñï) (f : Œ† (x : Fin k), T k x),
             +-ind ùüè (Fin k) (T (succ k)) (ind‚ÇÅ (Œª (w : ùüè), T (succ k) (0‚ÇÇ, w)) (z k))
                     (Œª (w : Fin k), s k w (f w))) m x
            </code></figure>

            
<h4>Vec-—Ç–∏–ø</h4>

<p>–¢–∏–ø –∑–∞–≤–∏—Å–∏–º–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –≤—ã–≤–æ–¥–∏–º –≤ –Ω–∞—à–µ–π —Å–∏—Å—Ç–µ–º–µ</p>

<figure><code>def Vec (A : U) : ‚Ñï ‚Üí U := ‚Ñï-iter U ùüè (Œª (X : U), A √ó X)
def vzero (A : U) : Vec A zero := ‚òÖ
def vsucc (A : U) (n : ‚Ñï) (head : A) (tail : Vec A n)
  : Vec A (succ n) := (head, tail)

def Vec-ind (A : U) (T : Œ† (n : ‚Ñï), Vec A n ‚Üí U) (z : T zero (vzero A))
    (s : Œ† (n : ‚Ñï) (x : A) (v : Vec A n), T n v ‚Üí T (succ n) (vsucc A n x v))
    (m : ‚Ñï) : Œ† (x : Vec A m), T m x
 := ‚Ñï-ind (Œª (k : ‚Ñï), Œ† (x : Vec A k), T k x)
          (ind‚ÇÅ (T zero) z)
          (Œª (k : ‚Ñï) (f : Œ† (x : Vec A k), T k x) (y : Vec A (succ k)),
             s k y.1 y.2 (f y.2)) m

def Vec-rec (A B : U) (z : B) (s : Œ† (n : ‚Ñï), A ‚Üí Vec A n ‚Üí B ‚Üí B)
    (m : ‚Ñï) : Vec A m ‚Üí B
 := Vec-ind A (Œª (n : ‚Ñï) (_ : Vec A n), B) z s m

def Vec-map (A B : U) (f : A ‚Üí B) (n : ‚Ñï) : Vec A n ‚Üí Vec B n
 := Vec-ind A (Œª (k : ‚Ñï) (_ : Vec A k), Vec B k) ‚òÖ
       (Œª (k : ‚Ñï) (x : A) (_ : Vec A k), vsucc B k (f x)) n  </code></figure>

<h4>I-–ø—Ä–µ—Ç–∏–ø</h4>

<p>–ü—Ä–µ—Ç–∏–ø—ã I –∏–º–µ—é—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–æ–Ω—Ü—ã –æ—Ç—Ä–µ–∑–∫–∞ 0 –∏ 1 –∏ —Ä–µ–∞–ª–∏–∑—É—é—Ç
   –∞–ª–≥–µ–±—Ä—É –¥–µ –ú–æ—Ä–≥–∞–Ω–∞ –Ω–∞ –Ω–∏—Ö. –ü–æ—ç—Ç–æ–º—É –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –∫—É–±–∏—á–µ—Å–∫–∏—Ö —Å–∏—Å—Ç–µ–º
   –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –¥–∏–∑—ä—é–Ω–∫—Ç–∏–≤–Ω—ã—Ö –Ω–æ—Ä–º–∞–ª—å–Ω—ã—Ö —Ñ–æ—Ä–º.</p>

<figure><code>eval:
  | EI -> VI
  | EDir d -> VDir d
  | EAnd (e1, e2) -> evalAnd (eval e1 ctx) (eval e2 ctx)
  | EOr (e1, e2) -> evalOr (eval e1 ctx) (eval e2 ctx)
  | ENeg e -> negFormula (eval e ctx)

inferV:
  | VI -> VPre Z.zero
  | VDir _ | VOr _ | VAnd _ | VNeg _ -> VI

act:
  | VI -> VI
  | VDir d -> VDir d
  | VAnd (u, v) -> evalAnd (act rho u) (act rho v)
  | VOr (u, v) -> evalOr (act rho u) (act rho v)
  | VNeg u -> negFormula (act rho u)

conv:
  | VI, VI -> true
  | VDir u, VDir v -> u = v

infer:
  | EI -> VPre Z.zero | EDir _ -> VI | ENeg e -> check ctx e VI; VI
  | EOr (e1, e2) | EAnd (e1, e2) -> check ctx e1 VI; check ctx e2 VI; VI
</code></figure>

<p>–ü—Ä–∏–º–µ—Ä —Ä–∞–±–æ—Ç—ã –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ –î–ù–§ —Å–æ–ª–≤–µ—Ä–∞:</p>

<figure><code>def ‚àÇ (i: I) := i ‚à® -i
def ‚àÇ-eq-neg-‚àÇ (i: I): Id I (‚àÇ i) (‚àÇ -i) := ref (‚àÇ i)
def min (i j: I) := i ‚àß j
def max (i j: I) := i ‚à® j
def ‚äï (i j: I) : I := (i ‚àß -j) ‚à® (-i ‚àß j)
def ‚äï-comm (i j: I): Id I (‚äï i j) (‚äï j i) := ref (‚äï i j)
def ‚àß-comm (i j: I): Id I (i ‚àß j) (j ‚àß i) := ref (i ‚àß j)
def ‚à®-comm (i j: I): Id I (i ‚à® j) (j ‚à® i) := ref (i ‚à® j)
def ¬¨-of-‚àß (i j: I): Id I -(i ‚àß j) (-i ‚à® -j) := ref -(i ‚àß j)
def ¬¨-of-‚à® (i j: I): Id I -(i ‚à® j) (-i ‚àß -j) := ref -(i ‚à® j)
def ‚àß-distrib-‚à® (i j k: I): Id I ((i ‚à® j)‚àß k) ((i ‚àß k)‚à®(j ‚àß k)) := ref ((i ‚à® j)‚àß k)
def ‚à®-distrib-‚àß (i j k: I): Id I ((i ‚àß j)‚à® k) ((i ‚à® k)‚àß(j ‚à® k)) := ref ((i ‚àß j)‚à® k)
def ‚àß-assoc (i j k: I): Id I (i ‚àß (j ‚àß k)) ((i ‚àß j) ‚àß k) := ref (i ‚àß (j ‚àß k))
</code></figure>

<h4>Id-—Ç–∏–ø</h4>

<p>–°–∏—Å—Ç–µ–º–∞ –í–æ–µ–≤–æ–¥—Å–∫–æ–≥–æ HTS –∞ —Ç–∞–∫–∂–µ –±–æ–ª–µ–µ –Ω–æ–≤—ã–µ —Å–∏—Ç–µ–º—ã 2LTT —Å–æ–¥–µ—Ä–∂–∞—Ç –≤ —Å–µ–±–µ –¥–≤–∞ –≤–∏–¥–∞ —Ä–∞–≤–µ–Ω—Å—Ç–≤:
–æ–¥–Ω–æ –¥–ª—è –ø—Ä–µ—Ç–∏–ø–æ–≤ (–≤ –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ –æ—Ç—Ä–µ–∑–∫–∞), –∞ –≤—Ç–æ—Ä–æ–µ –¥–ª—è —Ñ–∏–±—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö
—Ç–∏–ø–æ–≤ (–≤ –Ω–µ—à–µ–º —Å–ª—É—á–∞–µ –¥–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Ç–∏–ø–æ–≤).</p>

<figure><code>eval:
  | EId e -> VId (eval e ctx)
  | ERef e -> VRef (eval e ctx)
  | EJ e -> VJ (eval e ctx)

infer:
  | EId e -> let v = eval e ctx in implv v (implv v (VPre (extSet (infer ctx e))))
  | ERef e -> let v = eval e ctx in VApp (VApp (VId (infer ctx e)), v), v)
  | EJ e -> inferJ (eval e ctx) (infer ctx e)

app:
  | VApp (VApp (VApp (VApp (VJ _, _), _), f), _), VRef _ -> f

inferV:
  | VId v -> let n = extSet (inferV v) in implv v (implv v (VPre n))
  | VJ v -> inferJ v (inferV v)

act:
  | VId v -> VId (act rho v)
  | VRef v -> VRef (act rho v)
  | VJ v -> VJ (act rho v)

and inferJ v t =
  let x = freshName "x" in
  let y = freshName "y" in
  let pi = freshName "P" in
  let p = freshName "p" in
  let k = extSet t in
  let t = VPi (v, (x, fun x -> VPi (v, (y, fun y -> implv (idv v x y) (VPre k))))) in
  VPi (t, (pi, fun pi ->
  VPi (v, (x, fun x ->
  implv (app (app (app (pi, x), x), VRef x))
        (VPi (v, (y, fun y ->
           VPi (idv v x y, (p, fun p ->
             app (app (app (pi, x), y), p))))))))))
</code></figure>

<p>–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ –Ω–∞ –ø—Ä–µ—Ç–∏–ø–∞—Ö</p>

<figure><code>def ‚â§ (i j : I) := Id I (i ‚àß j) i
def ‚â• (i j : I) := ‚â§ j i

def ‚àß-split (i j : I) : Partial (1= i) (i ‚àß j) := [(i = 1) (j = 1) ‚Üí 1=1]
def ‚à®-left (i j : I) (p : 1= i) : 1= (i ‚à® j)
 := idJ I (Œª (i i‚Ä≤ : I) (_ : Id I i i‚Ä≤), Id I 1 (i‚Ä≤ ‚à® j)) 1 1=1 i p
def ‚à®-right (i j : I) (p : 1= j) : 1= (i ‚à® j) := ‚à®-left j i p 
def ‚àß-1 (i j : I) (p : 1= (i ‚àß j)) : 1= i := ‚àß-split i j p
def ‚àß-1‚Ä≤ (i j : I) (p : 1= (i ‚àß j)) : 1= i
 := cong-Id I I (Œª (k : I), k ‚à® i) 1 (i ‚àß j) p
def ‚àß-min-left  (i j : I) : ‚â§ (i ‚àß j) i := ref (i ‚àß j)
def ‚àß-min-right (i j : I) : ‚â§ (i ‚àß j) j := ref (i ‚àß j)
def ‚à®-max-left  (i j : I) : ‚â§ i (i ‚à® j) := ref i
def ‚à®-max-right (i j : I) : ‚â§ j (i ‚à® j) := ref j
def ‚àß-to-‚à® (i j : I) (p : Id I (i ‚àß j) i) : Id I (i ‚à® j) j
 := rev I j (i ‚à® j) (cong-Id I I (Œª (k : I), k ‚à® j) (i ‚àß j) i p)

def ‚â§-asymm (i j : I) (p : ‚â§ i j) (q : ‚â§ j i) : Id I i j
 := comp-Id I i (i ‚àß j) j (rev I (i ‚àß j) i p) q
def ‚â§-refl (i : I) : ‚â§ i i := ref i
def ‚â§-trans (i j k : I) (p : ‚â§ i j) (q : ‚â§ j k) : ‚â§ i k
 := comp-Id I (i ‚àß k) (i ‚àß j) i
    (comp-Id I (i ‚àß k) (i ‚àß j ‚àß k) (i ‚àß j)
      (rev I (i ‚àß j ‚àß k) (i ‚àß k) (cong-Id I I (min k) (i ‚àß j) i p))
      (cong-Id I I (min i) (j ‚àß k) j q)) p

def 0-is-min (i : I) : ‚â§ 0 i := ref 0
def 1-is-max (i : I) : ‚â§ i 1 := ref i

def Œî¬≤ := Œ£ (i j : I), ‚â§ i j
def Œî¬≤-1 : Œî¬≤ := (0, 0, ref 0)
def Œî¬≤-2 : Œî¬≤ := (0, 1, ref 0)
def Œî¬≤-3 : Œî¬≤ := (1, 1, ref 1)
def Œî¬≤-1-2 : PathP (&lt;_> Œî¬≤) Œî¬≤-1 Œî¬≤-2 := &lt;i> (0, i, ref 0)
def Œî¬≤-2-3 : PathP (&lt;_> Œî¬≤) Œî¬≤-2 Œî¬≤-3 := &lt;i> (i, 1, ref i)
def Œî¬≤-1-3 : PathP (&lt;_> Œî¬≤) Œî¬≤-1 Œî¬≤-3 := &lt;i> (i, i, ref i)

def Œî¬≥ := Œ£ (i j k : I), (‚â§ i j) √ó (‚â§ j k)
def Œî¬≥-1 : Œî¬≥ := (0, 0, 0, ref 0, ref 0)
def Œî¬≥-2 : Œî¬≥ := (0, 0, 1, ref 0, ref 0)
def Œî¬≥-3 : Œî¬≥ := (0, 1, 1, ref 0, ref 1)
def Œî¬≥-4 : Œî¬≥ := (1, 1, 1, ref 1, ref 1)
</code></figure>

<h4>–ß–∞—Å—Ç–∏—á–Ω—ã–µ —Ç–∏–ø—ã, –∫—É–±–∏—á–µ—Å–∫–∏–µ —Å–∏—Å—Ç–µ–º—ã</h4>

<figure><code>eval:
  | EPartial e -> let (i, _, _) = freshDim () in
    VLam (VI, (i, fun r -> let ts = mkSystem (List.map (fun mu ->
      (mu, eval e (faceEnv mu ctx))) (solve r One)) in VPartialP (VSystem ts, r)))
  | EPartialP (t, r) -> VPartialP (eval t ctx, eval r ctx)
  | ESystem xs -> VSystem (evalSystem ctx xs)

app:
  | VSystem ts, x -> reduceSystem ts x

inferV:
  | VPartialP (VSystem ts, _) -> begin match System.choose_opt ts with
    | Some (_, t) -> VPre (extSet (inferV t))
    | None        -> VPre Z.zero end
  | VPartialP (t, _) -> inferV (inferV t)
  | VSystem ts -> VPartialP (VSystem (System.map inferV ts), getFormulaV ts)

infer:
  | EPartial e -> let n = extSet (infer ctx e) in implv VI (VPre n)
  | EPartialP (u, r0) ->
    check ctx r0 VI; let t = infer ctx u in begin match t with
    | VPartialP (ts, r) -> eqNf r (eval r0 ctx); inferV (inferV ts)
    | _ -> failwith "Expected partial function into universe" end
  | ESystem ts -> checkOverlapping ctx ts;
    VPartialP (VSystem (System.mapi (fun mu -> infer (faceEnv mu ctx)) ts),
           eval (getFormula ts) ctx)

and evalSystem ctx = bimap (getRho ctx) (fun beta t -> eval t (faceEnv beta ctx))

and faceEnv alpha ctx =
  Env.map (fun (p, t, v) ->
  if p = Local then (p, updTerm alpha t, updTerm alpha v) else (p, t, v)) ctx
  |> Env.fold (fun p dir -> Env.add p (Local, Value VI, Value (VDir dir))) alpha

let reduceSystem ts x =
  match System.find_opt eps ts with
  | Some v -> v
  | None   -> VApp (VSystem ts, x)

and checkOverlapping ctx ts =
  System.iter (fun alpha e1 ->
    System.iter (fun beta e2 ->
      if comparable alpha beta then
        let ctx' = faceEnv (meet alpha beta) ctx in
        eqNf (eval e1 ctx') (eval e2 ctx')
      else ()) ts) ts
</code></figure>

<p>–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫—É–±–∏—á–µ—Å–∫–∏–µ —Å–∏—Å—Ç–µ–º</p>

<figure><code>
def œÜ (i : I) : Partial U‚ÇÅ (i ‚à® -i) := [(i = 0) ‚Üí U, (i = 1) ‚Üí U ‚Üí U]
def œÜ‚Ä≤ (i : I) : Partial U‚ÇÅ (i ‚à® -i) := [(i = 1) ‚Üí U ‚Üí U, (i = 0) ‚Üí U]
def œà (i j : I) : Partial U‚ÇÅ (-i ‚à® i ‚à® (i ‚àß j))
 := [(i = 1) ‚Üí U, (i = 1) (j = 1) ‚Üí U, (i = 0) ‚Üí U ‚Üí U]

def œÜ-0 : PathP (&lt;_> U‚ÇÅ) (œÜ 0 1=1) U := &lt;_> U
def œÜ-1 : PathP (&lt;_> U‚ÇÅ) (œÜ 1 1=1) (U ‚Üí U) := &lt;_> U ‚Üí U
def œÜ-eq-œÜ‚Ä≤ (i : I) : Id (Partial U‚ÇÅ (i ‚à® -i)) (œÜ i) (œÜ‚Ä≤ i) := ref (œÜ‚Ä≤ i)
def œÅ (i j : I) : Partial U‚ÇÅ (-i ‚à® (i ‚àß j)) := [(i = 0) ‚Üí U, (i = 1) (j = 1) ‚Üí U]
def Œ∫ : Partial U‚ÇÅ 1 := [(1 = 1) ‚Üí U]
def Œ∏ (A B : U) (a : A) (b : B) (œÜ : I)
  : PartialP [(œÜ = 0) ‚Üí A, (œÜ = 1) ‚Üí B] (œÜ ‚à® -œÜ) := [(œÜ = 0) ‚Üí a, (œÜ = 1) ‚Üí b]

def partial-app-test (A : U) (a : A) (œÜ : I) (p : 1= œÜ) : A := [(œÜ = 1) ‚Üí a] p
def Partial‚Ä≤ (A : U) (i : I) := Partial A i
def seg : PathP (&lt;_> I) 0 1 := &lt;i> i
def Partial-app (A : U) (i : I) (u : Partial A i) (p : 1= i) : A := u p
def Id-path (A : U) (a b : A) : Id A a b ‚Üí Path A a b
 := idJ A (Œª (a b : A) (_ : Id A a b), Path A a b) a (&lt;_> a) b
</code></figure>

<h4>–ö—É–±–∏—á–µ—Å–∫–∏–µ –ø–æ–¥—Ç–∏–ø—ã</h4>

<figure><code>eval:
  | ESub (a, i, u) -> VSub (eval a ctx, eval i ctx, eval u ctx)
  | EInc (t, r) -> VInc (eval t ctx, eval r ctx)
  | EOuc e -> ouc (eval e ctx)

app:
  | VInc (t, r), v -> inc t r v

inferV:
  | VSub (t, _, _) -> VPre (extSet (inferV t))
  | VInc (t, i) -> inferInc t i
  | VOuc v -> begin match inferV v with
    | VSub (t, _, _) -> t
    | _ -> raise (ExpectedSubtypeV v)  end

infer:
  | ESub (a, i, u) -> let n = extSet (infer ctx a) in check ctx i VI;
    check ctx u (partialv (eval a ctx) (eval i ctx)); VPre n
  | EInc (e, r) -> ignore (extKan (infer ctx e)); check ctx r VI;
    inferInc (eval e ctx) (eval r ctx)
  | EOuc e -> begin match infer ctx e with
      | VSub (t, _, _) -> t
      | _ -> raise (ExpectedSubtype e) end

conv:
  | VInc (t1, r1), VInc (t2, r2) -> conv t1 t2 && conv r1 r2
  | VOuc u, VOuc v -> conv u v

and inc t r = function | VOuc v -> v | v -> VApp (VInc (t, r), v)
and ouc v = match v, inferV v with
  | _, VSub (_, VDir One, u) -> app (u, VRef vone)
  | VApp (VInc _, v), _ -> v
  | _, _ -> VOuc v
</code></figure>

 <P>–ò–Ω—Ç–µ—Ä–Ω–∞–ª–∏–∑–∞—Ü–∏—è –∫—É–±–∏—á–µ—Å–∫–∏—Ö –ø–æ–¥—Ç–∏–ø–æ–≤</P>

<figure><code>
def sub (A : U) (i : I) (u : Partial A i) : V := A[i ‚Ü¶ u]
def inc‚Ä≤ (A : U) (i : I) (a : A) : sub A i [(i = 1) ‚Üí a] := inc A i a
def ouc‚Ä≤ (A : U) (i : I) (u : Partial A i) (a : A[i ‚Ü¶ u]) : A := ouc a
</code></figure>

<h4>Glue-—Ç–∏–ø</h4>

<p>–û—Å–Ω–æ–≤–Ω–∞—è —Ü–µ–ª—å —Ç–∏–ø–æ–≤ Glue ‚Äî –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –∫—É–±, –≤ –∫–æ—Ç–æ—Ä–æ–º –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≥—Ä–∞–Ω–∏
   –±—ã–ª–∏ –∑–∞–º–µ–Ω–µ–Ω—ã —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏. –≠—Ç–æ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ —Ç–æ–º—É, –∫–∞–∫ hcomp
   –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –∑–∞–º–µ–Ω–∏—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≥—Ä–∞–Ω–∏ –∫—É–±–∞, —Å–æ—Å—Ç–∞–≤–∏–≤ –µ–≥–æ –∏–∑ –¥—Ä—É–≥–∏—Ö –∫—É–±–æ–≤,
   –Ω–æ –¥–ª—è —Ç–∏–ø–æ–≤ Glue –≤—ã –º–æ–∂–µ—Ç–µ —Å–æ—Å—Ç–∞–≤–ª—è—Ç—å —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç—ã –≤–º–µ—Å—Ç–æ –ø—É—Ç–µ–π.
   –û—Ç—Å—é–¥–∞ –≤—ã—Ç–µ–∫–∞–µ—Ç –ø—Ä–∏–Ω—Ü–∏–ø —É–Ω–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç–∏, –∏ —ç—Ç–æ —Ç–æ, —á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç
   –Ω–∞–º –ø–µ—Ä–µ–º–µ—â–∞—Ç—å—Å—è –ø–æ –ø—É—Ç—è–º, –ø–æ—Å—Ç—Ä–æ–µ–Ω–Ω—ã–º –∏–∑ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç–µ–π. </p>

<figure><code>
conv:
  | VGlue v, VGlue u -> conv u v
  | VUnglue v, VUnglue u -> conv u v
  | VGlueElem (r1,u1,a1), VGlueElem (r2,u2,a2) ->
    conv r1 r2 && conv u1 u2 && conv a1 a2
  
app:
  | VApp (VGlue _, VDir One), u -> vfst (app (u, VRef vone))

act:
  | VGlue v -> VGlue (act rho v)
  | VGlueElem (r, u, a) -> VGlueElem (act rho r, act rho u, act rho a)
  | VUnglue v -> VUnglue (act rho v)

conv:
  | VGlue v, VGlue u -> conv u v
  | VUnglue v, VUnglue u -> conv u v
  | VGlueElem (r1, u1, a1), VGlueElem (r2, u2, a2) ->
    conv r1 r2 && conv u1 u2 && conv a1 a2

infer:
  | EGlue e -> ignore (extKan (infer ctx e)); inferGlue (eval e ctx)
  | EGlueElem (e, u0, a) ->
    check ctx e VI; let r = eval e ctx in let t = infer ctx a in
    check ctx u0 (partialv (equivPtSingl t) r); let u = eval u0 ctx in
    List.iter (fun mu -> let v = app (upd mu u, VRef vone) in
      let f = vfst (vfst (vsnd v)) in
      eqNf (eval a (faceEnv mu ctx)) (app (f, vsnd (vsnd v)))) (solve r One);
    inferGlueElem r u t
  | EUnglue e -> let (t, _, _) = extGlue (infer ctx e) in t

inferV:
  | VGlue t -> inferGlue t
  | VGlueElem (r, u, a) -> inferGlueElem r u (inferV a)
  | VUnglue v -> let (t, _, _) = extGlue (inferV v) in t

and fiber t1 t2 f y =
  VSig (t1, (freshName "a", fun x -> pathv (idp t2) y (app (f, x)))) 

and isContr t = let x = freshName "x" in let y = freshName "y" in
  VSig (t, (x, fun x -> VPi (t, (y, fun y -> pathv (idp t) x y))))
  
and isEquiv t1 t2 f = VPi (t2, (freshName "b", isContr << fiber t1 t2 f))
and equiv t1 t2 = VSig (implv t1 t2, (freshName "f", isEquiv t1 t2))
and equivSingl t0 = VSig (inferV t0, (freshName "T", fun t -> equiv t t0))
and equivPtSingl t0 = VSig (inferV t0, (freshName "T", fun t -> prodv (equiv t t0) t))

and inferGlue t = let (r, _, _) = freshDim () in let k = inferV t in
  VPi (VI, (r, fun r -> implv (partialv (equivSingl t) r) k))

and inferGlueElem r u t =
  VApp (VApp (VGlue t, r),
        VSystem (walk (fun v -> VPair (ref None, vfst v, vfst (vsnd v))) r u))

</code></figure>

<p>–¢–µ—Å—Ç–∏—Ä—É—é—Ç—Å—è Glue —Ç–∏–ø—ã –æ–±—ã—á–Ω–æ —Ç–∏–ø–æ–º-—É–Ω–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å—é [Equiv -> Path] –í–æ–µ–≤–æ–¥—Å–∫–æ–≥–æ:</p>

<figure><code>
def univ-formation (A B : U)
 := equiv A B -> PathP (&lt;_> U) A B

def univ-intro (A B : U)
  : univ-formation A B
 := Œª (e : equiv A B), &lt;i> Glue B (‚àÇ i)
    [ (i = 0) ‚Üí (A, e),
      (i = 1) ‚Üí (B, idEquiv B)]

def univ-elim (A B : U) (p : PathP (&lt;_> U) A B) : equiv A B
 := transp (&lt;i> equiv A (p @ i)) 0 (idEquiv A)

def univ-computation (A B : U) (p : PathP (&lt;_> U) A B)
  : PathP (&lt;_> PathP (&lt;_> U) A B) (univ-intro A B (univ-elim A B p)) p
 := &lt;j i> Glue B (j ‚à® ‚àÇ i)
          [ (i = 0) ‚Üí (A, univ-elim A B p), (i = 1) ‚Üí (B, idEquiv B),
            (j = 1) ‚Üí (p @ i, univ-elim (p @ i) B (&lt;k> p @ (i \/ k))) ]
</code></figure>

<P>–ê —Ç–∞–∫–∂–µ –ú–∏–Ω–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å—é [Iso -> Equiv] –∞–≤—Ç–æ—Ä—Å—Ç–≤–∞ –®—É–ª—å–º–∞–Ω–∞, –õ—é–º—Å–¥–µ–π–Ω–∞, –£–æ—Ä—Ä–µ–Ω–∞ –∏ –õ–∏–∫–∞—Ç—ã,
   –∏–∑–≤–µ—Å—Ç–Ω—ã–µ —Ç–∞–∫–∂–µ –∫–∞–∫ –∞–≤—Ç–æ—Ä—ã gradLemma:</P>

<figure><code>def mini-Form (A B : U) : U
 := iso A B -> equiv A B

def mini-Intro (A B : U)
  : mini-Form A B
 := \ (x : iso A B), univ-elim A B (isoPath A B x.f x.g x.s x.t)

def mini-Elim (A B : U)
  : equiv A B -> iso A B
 := \ (x : equiv A B),
    ( x.f,
      inv-equiv A B x,
      ret-equiv A B x,
      sec-equiv A B x,
      star
    )
</code></figure>
<p>–∏ –Æ–Ω–∏–º–æ—Ä—Ñ–∏–∑–º–æ–º [Iso -> Path] –∞–≤—Ç–æ—Ä—Å—Ç–≤–∞ CCHM (–ö–æ—ç–Ω, –ö–æ–∫–∞–Ω, –ì—É–±–µ—Ä, –ú–æ—Ä—Ç–±–µ—Ä–≥)
   —Å –±–æ–ª—å—à–∏–º —Ç–µ—Ä–º–æ–º lemIso:</P>

<figure><code>def iso-Form (A B: U) : U‚ÇÅ
 := iso A B -> PathP (&lt;_>U) A B

def iso-Intro (A B: U)
  : iso-Form A B
 := \ (x : iso A B), isoPath A B x.f x.g x.s x.t

def iso-Elim (A B : U)
  : PathP (&lt;_> U) A B -> iso A B
 := Œª (p : PathP (&lt;_> U) A B),
      ( coerce A B p,
        coerce B A (&lt;i> p @ -i),
        trans‚Åª¬π-trans A B p,
        Œª (a : A), &lt;<k> trans-trans‚Åª¬π A B p a @ -k,
        star
      )

    </code></figure>
    
    <p>–í–ø–µ—Ä–≤—ã–µ –≥–æ–º–æ—Ç–æ–ø–∏—á–µ—Å–∫–∞—è —Å–∏—Å—Ç–µ–º–∞ –Ω–∞ Coq –±—ã–ª–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–∞ –ü–µ–ª–∞–π–æ, –£–æ—Ä—Ä–µ–Ω–æ–º –∏ –í–æ–µ–≤–æ–¥—Å–∫–∏–º –≤ 2012 –≥–æ–¥—É.</P>
    
    <figure><code>def fiber (A B : U) (f: A -> B) (y : B): U := Œ£ (x : A), Path B y (f x)
def isContr' (A: U) : U := Œ£ (x: A), Œ† (y: A), Path A x y
def isEquiv (A B : U) (f : A -> B) : U := Œ† (y : B), isContr (fiber A B f y)
def equiv (A B : U) : U := Œ£ (f : A -> B), isEquiv A B f

def contrSingl (A : U) (a b : A) (p : Path A a b)
  : Path (Œ£ (x : A), Path A a x) (a,&lt;_>a) (b,p) := &lt;i> (p @ i, &lt;j> p @ i /\ j)
def idIsEquiv (A : U) : isEquiv A A (id A)
 := \ (a : A), ((a,&lt;_>a),\ (z : fiber A A (id A) a), contrSingl A a z.1 z.2)
def idEquiv (A : U) : equiv A A := (id A, isContrSingl A)

def isInjective (A B : U) (f : A -> B) : U
 := Œ† (x y : A), Path B (f x) (f y) -> Path A x y
def isInjective' (A B : U) (f : A -> B): U
 := Œ† (b : B), isProp (fiber A B f b)
def injective (A B : U) : U := Œ£ (f : A -> B), isInjective A B f

def isEmbedding (A B : U) (f : A -> B) : U
 := Œ† (x y : A), isEquiv (Path A x y) (Path B (f x) (f y)) (cong A B f x y)
def embedding (A B : U) : U := Œ£ (f : A -> B), isEmbedding A B f

def inv-equiv (A B : U) (w : equiv A B) : B -> A := Œª (y : B), (w.2 y).1.1
def ret-equiv (A B : U) (w : equiv A B) (y : B)
  : Path B (w.1 (inv-equiv A B w y)) y
 := &lt;i> (w.2 y).1.2 @ -i

def sec-equiv (A B : U) (w : equiv A B) (x : A)
  : Path A (inv-equiv A B w (w.1 x)) x
 := &lt;i> ((w.2 (w.1 x)).2 (x, &lt;j> w.1 x) @ i).1
</code></figure>

<p>–ò–Ω—Ç–µ—Ä–Ω–∞–ª–∏–∑–∞—Ü–∏—è Glue —Ç–∏–ø–æ–≤</p>

<figure><code>def Glue‚Ä≤ (A : U) (œÜ : I) (e : Partial (Œ£ (T : U), equiv T A) œÜ)
  : U := Glue A œÜ e

def glue‚Ä≤ (A : U) (œÜ : I) (u : Partial (Œ£ (T : U), equiv T A √ó T) œÜ)
    (a : A[œÜ ‚Ü¶ [(œÜ = 1) ‚Üí (u 1=1).2.1.1 (u 1=1).2.2]])
 := glue œÜ u (ouc a)

def unglue‚Ä≤ (A : U) (œÜ : I) (e : Partial (Œ£ (T : U), equiv T A) œÜ)
    (b : Glue A œÜ e)
  : A := unglue b
   </code></figure>


<h4>–°—Ç–µ–∫ –¥–µ –†–∞–º–∞</h4>

<p>–°—Ç–µ–∫ –¥–µ –†–∞–º–∞ –∏–ª–∏ –ò–Ω—Ñ–∏–Ω–∏—Ç–∏–∑–µ–º–∞–ª—å–Ω–∞—è –ú–æ–¥–∞–ª—å–Ω–æ—Å—Ç—å –§–æ—Ä–º—ã &mdash; —ç—Ç–æ –±–∞–∑–æ–≤—ã–π –ø—Ä–∏–º–∏—Ç–∏–≤
   –¥–ª—è –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞ —Ç–µ–æ—Ä–µ–º –∏–∑ —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–æ–π –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–∏. –î–∞–Ω–Ω—ã–π
   —Ç–µ–æ—Ä–µ—Ç–∏–∫–æ-—Ç–∏–ø–æ–≤–æ–π –∞–ø–ø–∞—Ä—Ç –±—ã–ª —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω –≤–ø–µ—Ä–≤—ã–µ –§–µ–ª–∏–∫—Å–æ–º –ß–µ—Ä—É–±–∏–Ω–∏ –ø–æ–¥ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ–º –£—Ä—Å–∞ –®—Ä–∞–π–±–µ—Ä–∞.
   –ü—Ä—É–≤–µ—Ä Anders —Ä–µ–∞–ª–∏–∑—É–µ—Ç –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—É—é —Å–µ–º–∞–Ω—Ç–∏–∫—É —Å—Ç–µ–∫–∞ –¥–µ –†–∞–º–∞.</p>

<figure><code>eval:
  | EIm e -> VIm (eval e ctx)
  | EInf e -> inf (eval e ctx)
  | EJoin e -> join (eval e ctx)
  | EIndIm (a, b) -> VIndIm (eval a ctx, eval b ctx)

act:
  | VIm t -> VIm (act rho t)
  | VInf v -> inf (act rho v)
  | VJoin v -> join (act rho v)
  | VIndIm (a, b) -> VIndIm (act rho a, act rho b)

inferV:
  | VIm t -> inferV t
  | VInf v -> VIm (inferV v)
  | VJoin v -> extIm (inferV v)
  | VIndIm (a, b) -> inferIndIm a b

infer:
  | EIm e -> let t = infer ctx e in ignore (extSet t); t
  | EInf e -> VIm (infer ctx e)
  | EJoin e -> let t = extIm (infer ctx e) in ignore (extIm t); t
  | EIndIm (a, b) -> ignore (extSet (infer ctx a)); let t = eval a ctx in
    let (c, (x, g)) = extPiG (infer ctx b) in eqNf (VIm t) c;
    ignore (extSet (g (Var (x, c)))); inferIndIm t (eval b ctx)

conv:
  | VIm u, VIm v -> conv u v
  | VInf u, VInf v -> conv u v
  | VJoin u, VJoin v -> conv u v
  | VIndIm (a1, b1), VIndIm (a2, b2) -> conv a1 a2 && conv b1 b2

app:
  | VApp (VIndIm _, f), VInf a -> app (f, a)
  | VApp (VIndIm (a, b), VLam (t, (x, g))), v -> let u = g (Var (x, t)) in
    if mem x u then VApp (VApp (VIndIm (a, b), VLam (t, (x, g))), v) else u

and join = function | VInf v -> v | v -> VJoin v
and inf = function | VJoin v -> v | v -> VInf v

</code></figure>

<p>–°—Ç–µ–∫ –¥–µ –†–∞–º–∞ —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç—Å—è –¥–æ–∫—Ç–æ—Ä—Å–∫–æ–π –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–µ–π –§–µ–ª–∏–∫—Å–∞ –ß–µ—Ä—É–±–∏–Ω–∏ –ø–æ—Å–≤—è—â–µ–Ω–Ω–æ–π –∫–∞—Ä—Ç–∞–Ω–æ–≤–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–∏:</p>

<figure><code>
def Œπ (A : U) (a : A) : ‚Ñë A := ‚Ñë-unit a
def Œº (A : U) (a : ‚Ñë (‚Ñë A)) := ‚Ñë-join a

def is-coreduced (A : U) : U := isEquiv A (‚Ñë A) (Œπ A)
def ‚Ñë-coreduced (A : U) : is-coreduced (‚Ñë A)
 := isoToEquiv (‚Ñë A) (‚Ñë (‚Ñë A)) (Œπ (‚Ñë A)) (Œº A)
       (Œª (x : ‚Ñë (‚Ñë A)), &lt;_> x) (Œª (y : ‚Ñë A), &lt;_> y)

def ind-‚ÑëŒ≤ (A : U) (B : ‚Ñë A ‚Üí U) (f : Œ† (a : A), ‚Ñë (B (Œπ A a)))
    (a : A) : Path (‚Ñë (B (Œπ A a))) (ind-‚Ñë A B f (Œπ A a)) (f a) := &lt;_> f a

def trans-‚Ñë (A : I ‚Üí U) (a : A 0) : ‚Ñë (A 1) := ‚Ñë-unit (transp (&lt;i> A i) 0 a)
def trans-‚Ñë‚Ä≤ (A : I ‚Üí U) (a : A 0) : ‚Ñë (A 1) := transp (&lt;i> ‚Ñë (A i)) 0 (‚Ñë-unit a)

def trans-‚Ñë-is-correct (A : I ‚Üí U) (a : A 0)
  : Path (‚Ñë (A 1)) (trans-‚Ñë A a) (trans-‚Ñë‚Ä≤ A a) := &lt;_> trans-‚Ñë A a

def hcomp-‚Ñë (A : U) (r : I) (u : I ‚Üí Partial A r) (u‚ÇÄ : A[r ‚Ü¶ u 0])
  : ‚Ñë A := ‚Ñë-unit (hcomp A r u (ouc u‚ÇÄ))

def hcomp-‚Ñë‚Ä≤ (A : U) (r : I) (u : I ‚Üí Partial A r) (u‚ÇÄ : A[r ‚Ü¶ u 0])
  : ‚Ñë A := hcomp (‚Ñë A) r (Œª (i : I), [(r = 1) ‚Üí ‚Ñë-unit (u i 1=1)]) (‚Ñë-unit (ouc u‚ÇÄ))

def hcomp-‚Ñë-is-correct (A : U) (r : I) (u : I ‚Üí Partial A r) (u‚ÇÄ : A[r ‚Ü¶ u 0])
  : Path (‚Ñë A) (hcomp-‚Ñë A r u u‚ÇÄ) (hcomp-‚Ñë‚Ä≤ A r u u‚ÇÄ) := &lt;_> hcomp-‚Ñë A r u u‚ÇÄ

def ‚Ñë-ind (A : U) (B : ‚Ñë A ‚Üí U) (c : Œ† (a : ‚Ñë A), is-coreduced (B a))
    (f : Œ† (a : A), B (Œπ A a)) (a : ‚Ñë A) : B a
 := (c a (ind-‚Ñë A B (Œª (x : A), Œπ (B (Œπ A x)) (f x)) a)).1.1

def ‚Ñë-indŒ≤ (A : U) (B : ‚Ñë A ‚Üí U) (c : Œ† (a : ‚Ñë A), is-coreduced (B a))
    (f : Œ† (a : A), B (Œπ A a)) (a : A)
  : Path (B (Œπ A a)) (f a) ((‚Ñë-ind A B c f) (Œπ A a))
 := &lt;i> sec-equiv (B (Œπ A a)) (‚Ñë (B (Œπ A a))) (Œπ (B (Œπ A a)), c (Œπ A a)) (f a) @ -i

def ‚Ñë-rec (A B : U) (c : is-coreduced B) (f : A ‚Üí B) : ‚Ñë A ‚Üí B
 := ‚Ñë-ind A (Œª (_ : ‚Ñë A), B) (Œª (_ : ‚Ñë A), c) f

def ‚Ñë-recŒ≤ (A B : U) (c : is-coreduced B) (f : A ‚Üí B) (a : A)
  : PathP (<_> B) (f a) ((‚Ñë-rec A B c f) (Œπ A a))
 := ‚Ñë-indŒ≤ A (Œª (_ : ‚Ñë A), B) (Œª (_ : ‚Ñë A), c) f a

def ‚Ñë-rec‚Ä≤ (A B : U) (f : A ‚Üí ‚Ñë B) : ‚Ñë A ‚Üí ‚Ñë B := ind-‚Ñë A (Œª (x : ‚Ñë A), B) f
def ‚Ñë-rec‚Ä≤-Œ≤ (A B : U) (f : A ‚Üí ‚Ñë B) (x : A)
  : Path (‚Ñë B) (‚Ñë-rec‚Ä≤ A B f (‚Ñë-unit x)) (f x) := <_> f x

def ‚Ñë-app (A B : U) (f : A ‚Üí B) : ‚Ñë A ‚Üí ‚Ñë B
 := ‚Ñë-rec A (‚Ñë B) (‚Ñë-coreduced B) (‚àò A B (‚Ñë B) (Œπ B) f)

def ‚Ñë-naturality (A B : U) (f : A ‚Üí B) (a : A)
  : Path (‚Ñë B) ((Œπ B) (f a)) ((‚Ñë-app A B f) (Œπ A a))
 := &lt;_> ‚Ñë-unit (f a)

def ~ (X : U) (a x‚Ä≤ : X) : U := Path (‚Ñë X) (Œπ X a) (Œπ X x‚Ä≤)
def ùîª (X : U) (a : X) : U := Œ£ (x‚Ä≤ : X), ~ X a x‚Ä≤
def unitDisc (X : U) (x : ‚Ñë X) : U := Œ£ (x‚Ä≤ : X), Path (‚Ñë X) x (Œπ X x‚Ä≤)
def starDisc (X : U) (x : X) : ùîª X x := (x, idp (‚Ñë X) (Œπ X x))
def T‚àû (A : U) : U := Œ£ (a : A), ùîª A a

def inf-prox-ap (X Y : U) (f : X ‚Üí Y) (x x‚Ä≤ : X) (p : ~ X x x‚Ä≤)
  : ~ Y (f x) (f x‚Ä≤) := &lt;i> ‚Ñë-app X Y f (p @ i)
</code></figure>

<h4>–û–ø–µ—Ä–∞—Ü–∏–∏ –ö–∞–Ω–∞</h4>

<p>–ë–∞–∑–∏—Å –æ–ø–µ—Ä–∞—Ü–∏–π –ö–∞–Ω–∞ CHM –≤–µ—Ä—Å–∏–∏ CCHM –∫—É–±–∏—á–µ—Å–∫–æ–π —Ç–µ–æ—Ä–∏–∏ —Ç–∏–ø–æ–≤ —Å–æ—Å—Ç–æ–∏—Ç –∏–∑
   –æ–ø–µ—Ä–∞—Ü–∏–∏ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞ transp –∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≥–æ–º–æ–≥–µ–Ω–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ hcomp. –í–∏—Ç–∞–ª—å–Ω—ã–º
   –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã—Ö –≤—ã—Å—à–∏—Ö –∏–Ω–¥—É–∫—Ç–∏–≤–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–ª—è CCHM —Ç–µ–æ—Ä–∏–∏
   –æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –Ω–∞–ª–∏—á–∏–µ –∏–º–µ–Ω–Ω–æ —Ç–∞–∫–æ–≥–æ –±–∞–∑–∏—Å–∞ –≤ —è–¥—Ä–µ, –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ
   –≤–æ–∑–Ω–∏–∫–∞—é—Ç –ø—É—Å—Ç—ã–µ —Å–∏—Å—Ç–µ–º—ã –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –±–µ—Ç–∞-–Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏. 
.</p>

<figure><code>
infer:
  | ETransp (p, i) -> inferTransport ctx p i
  | EHComp (e, i, u, u0) -> let t = eval e ctx in let r = eval i ctx in
    ignore (extKan (infer ctx e)); check ctx i VI;
    check ctx u (implv VI (partialv t r)); check ctx u0 t;
    List.iter (fun phi -> let ctx' = faceEnv phi ctx in
      eqNf (eval (hcompval u) ctx') (eval u0 ctx')) (solve r One); t

inferV:
  | VTransp (p, _) -> implv (appFormula p vzero) (appFormula p vone)
  | VHComp (t, _, _, _) -> t

conv:
  | VTransp (p, i), VTransp (q, j) -> conv p q && conv i j
  | VHComp (t1, r1, u1, v1), VHComp (t2, r2, u2, v2) ->
    conv t1 t2 && conv r1 r2 && conv u1 u2 && conv v1 v2

app:
  | VTransp (p, i), u0 -> transp p i u0

act:
  | VTransp (p, i)       -> VTransp (act rho p, act rho i)
  | VHComp (t, r, u, u0) -> hcomp (act rho t) (act rho r) (act rho u) (act rho u0)

and transp p phi u0 = match p with
  | VPLam (VLam (VI, (i, g))) -> transport i (g (Var (i, VI))) phi u0
  | _ -> VApp (VTransp (p, phi), u0)

and inferTransport ctx p i =
  check ctx i VI;
  let u0 = appFormulaE ctx p ezero in
  let u1 = appFormulaE ctx p eone in
  let (t, _, _) = extPathP (infer ctx p) in
  ignore (extKan (inferV (appFormula t (Var (freshName "Œπ", VI)))));
  let (j, e, v) = freshDim () in let ctx' = upLocal ctx j VI v in
  List.iter (fun phi -> let rho = faceEnv phi ctx' in
    eqNf (appFormulaE rho p ezero) (appFormulaE rho p e))
    (solve (eval i ctx) One);
  implv u0 u1

and transport i p phi u0 = match p, phi, u0 with
  | _, VDir One, _ -> u0
  | VKan _, _, _ -> u0
  | VEmpty, _, _ -> u0
  | VUnit, _, _ -> u0
  | VBool, _, _ -> u0
  | VPi (t, (_, b)), _, _ -> let x = fresh (name "x") in
    let j = freshName "Œπ" in let k = freshName "Œ∫" in
    VLam (act0 i vone t, (x, fun x ->
      let v = transFill j (act0 i (VNeg (dim j)) t) phi x in
      transport k (swap i k (b (v (VNeg (dim k)))))
        phi (app (u0, v vone))))
  | VSig (t, (_, b)), _, _ ->
    let j = freshName "Œπ" in let k = freshName "Œ∫" in
    let v1 = transFill j (swap i j t) phi (vfst u0) in
    let v2 = transport k (swap i k (b (v1 (dim k)))) phi (vsnd u0) in
    VPair (ref None, v1 vone, v2)
  | VApp (VApp (VPathP p, v), w), _, _ ->
    let j = freshName "Œπ" in let k = freshName "Œ∫" in
    VPLam (VLam (VI, (j, fun j ->
      let uj = appFormula u0 j in let r = evalOr phi (evalOr j (negFormula j)) in
      comp (fun k -> appFormula (act0 i k p) j) r k
        (VSystem (unionSystem (border (solve phi One) uj)
                 (unionSystem (border (solve j Zero) (swap i k v))
                              (border (solve j One)  (swap i k w))))) uj)))
  | W (t, (x, b)), _, VApp (VApp (VSup _, a), f) ->
    let j = freshName "Œπ" in let k = freshName "Œ∫" in
    let v1 = transFill j (swap i j t) phi a in
    let v2 = transport k (swap i k (implv (b (v1 (dim k))) (W (t, (x, b))))) phi f in
    let t' = act0 i vone t in
    VApp (VApp (VSup (t', VLam (t', (fresh x, b >> act0 i vone))), v1 vone), v2)
  | VIm t, _, VInf a -> inf (transport i t phi a)
  | _, _, _ -> VApp (VTransp (VPLam (VLam (VI, (i, fun j -> act0 i j p))), phi), u0)

and transFill i p phi u0 j = let (k, _, _) = freshDim () in
  transport k (act0 i (evalAnd (dim k) j) p) (evalOr phi (negFormula j)) u0

and hcomp t r u u0 = let i = freshName "Œπ" in kan t r i (app (u, dim i)) u0

and kan t r i u u0 = match t, r, u, u0 with
  | _, VDir One, _, _ -> app (act0 i vone u, VRef vone)
  | VPi (t, (x, b)), _, _, _ -> VLam (t, (fresh x, fun y -> kan (b y) r i
    (VSystem (walk (fun v -> app (v, y)) r u)) (app (u0, y))))
  | VSig (t, (_, b)), _, _, _ -> let k = freshName "Œ∫" in
    let v1 = hfill t r k (VSystem (walk (vfst >> act0 i (dim k)) r u)) (vfst u0) in
    let v2 = comp (v1 >> b) r i (VSystem (walk vsnd r u)) (vsnd u0) in
    VPair (ref None, v1 vone, v2)
  | VApp (VApp (VPathP t, v), w), _, _, _ ->
    let j = freshName "Œπ" in
    VPLam (VLam (VI, (j, fun j ->
      kan (appFormula t j) (evalOr r (evalOr j (negFormula j))) i
          (VSystem (unionSystem (walk (flip appFormula j) r u)
                   (unionSystem (border (solve j One)  w)
                                (border (solve j Zero) v))))
          (appFormula u0 j))))
  | VIm t, _, VSystem u, VInf u0 when System.for_all (fun _ -> isInf) u ->
    VInf (kan t r i (VSystem (System.map extInf u)) u0)
  | _, _, _, _ -> VHComp (t, r, VLam (VI, (i, fun j ->
    VSystem (walk (act0 i j) r u))), u0)

and comp t r i u u0 = let j = freshName "Œπ" in
  kan (t vone) r i
      (VSystem (walk (transport j (t (evalOr (dim i) (dim j))) (dim i)) r u))
      (transport j (t (dim j)) vzero u0)

and hfill t r i u u0 j = let k = freshName "Œ∫" in
  kan t (evalOr (negFormula j) r) k
    (VSystem (unionSystem (walk (act0 i (evalAnd (dim k) j)) r u)
      (border (solve j Zero) u0))) u0

</code></figure>

<h4>–£—Ä–∞–≤–Ω–µ–Ω–∏—è –ì—É–±–µ—Ä–∞</h4>

<p>–û–ø–µ—Ä–∞—Ü–∏–∏ –ö–∞–Ω–∞ –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è —É—Ä–∞–≤–Ω–µ–Ω–∏—è–º–∏ –ì—É–±–µ—Ä–∞ (reality check), –∫–æ—Ç–æ—Ä—ã–π
   –≤–ø–µ—Ä–≤—ã–µ —Å–æ–±—Ä–∞–ª –≥—Ä–∞–Ω–∏—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è CHM –±–∞–∑–∏—Å–∞. </p>

<figure><code>transp‚Å± N œÜ u‚ÇÄ = u‚ÇÄ
transp‚Å± U œÜ A = A
transp‚Å± (Œ† (x : A), B) œÜ u‚ÇÄ v = transp‚Å± B(x/w) œÜ (u‚ÇÄ w(i/0)),
  where [ w = transpFill‚Åª‚Å± A œÜ v, v : A(i/1) ]
transp‚Å± (Œ£ (x : A), B) œÜ u‚ÇÄ = (transp‚Å± A œÜ (u‚ÇÄ.1),transp‚Å± B(x/v) œÜ(u‚ÇÄ.2)),
  where [ v = transpFill‚Å± A œÜ u‚ÇÄ.1 ]
transp‚Å± (Path ≤ A v w) œÜ u‚ÇÄ =„Äàj„Äâcomp‚Å± A [œÜ ‚Ü¶ u‚ÇÄ j, (j=0) ‚Ü¶ v, (j=1) ‚Ü¶ w] (u‚ÇÄ j),
  where [ u : A(j/0), v : A(j/1) ]
transp‚Å± (Glue [œÜ ‚Ü¶ (T,w)] A) œà u‚ÇÄ = glue [œÜ(i/1) ‚Ü¶ t‚Ä≤‚ÇÅ] a‚Ä≤‚ÇÅ : B(i/1)
transp‚Åª‚Å± A œÜ u = (transp‚Å± A(i/1‚àíi) œÜ u)(i/1‚àíi) : A(i/0)
transpFill‚Å± A œÜ u‚ÇÄ = transp ≤ A(i/i‚àßj) (œÜ‚à®(i=0)) u‚ÇÄ : A
hfill‚Å± A [œÜ ‚Ü¶ u] u‚ÇÄ = hcomp ≤ A [œÜ ‚Ü¶ u(i/i‚àßj), (i=0) ‚Ü¶ u‚ÇÄ] u‚ÇÄ : A
hcomp‚Å± N [œÜ ‚Ü¶ 0] 0 = 0
hcomp‚Å± N [œÜ ‚Ü¶ S u] (S u‚ÇÄ) = S (hcomp‚Å± N [œÜ ‚Ü¶ u] u‚ÇÄ)
hcomp‚Å± U [œÜ ‚Ü¶ E] A = Glue [œÜ ‚Ü¶ (E(i/1), equiv‚Å± E(i/1‚àíi))] A
hcomp‚Å± (Œ† (x : A), B) [œÜ ‚Ü¶ u] u‚ÇÄ v = hcomp‚Å± B(x/v) [œÜ ‚Ü¶ u v] (u‚ÇÄ v)
hcomp‚Å± (Œ£ (x : A), B) [œÜ ‚Ü¶ u] u‚ÇÄ
   = (v(i/1), comp‚Å± B(x/v) [œÜ ‚Ü¶ u.2] u‚ÇÄ.2),
        where [ v = hfill‚Å± A [œÜ ‚Ü¶ u.1] u‚ÇÄ.1 ]
hcomp‚Å± (Path ≤ A v w) [œÜ ‚Ü¶ u] u‚ÇÄ
   = „Äàj„Äâ hcomp‚Å± A [ œÜ ‚Ü¶ u j, (j = 0) ‚Ü¶ v, (j = 1) ‚Ü¶ w ] (u‚ÇÄ j)
hcomp‚Å± (Glue [œÜ ‚Ü¶ (T,w)] A) [œà ‚Ü¶ u] u‚ÇÄ = glue [œÜ ‚Ü¶ t‚ÇÅ] a‚ÇÅ
   = glue [œÜ ‚Ü¶ u(i/1)] (unglue u(i/1))
   = u(i/1) : Glue [œÜ ‚Ü¶ (T,w)] A,
         where [ t‚ÇÅ = u(i/1) : T,
                 a‚ÇÅ = unglue u(i/1) : A,
                 glue [œÜ ‚Ü¶ t‚ÇÅ] a1 = t‚ÇÅ : T ]
</code></figure>

<h4>–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —è–∑—ã–∫–∞</h4>

<p>Anders –ø–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –≤–º–µ—Å—Ç–µ —Å –±–∞–∑–æ–≤–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π –∫–∞–∫ –ø–∞–∫–µ—Ç –ø–∞–∫–µ—Ç–Ω–æ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ OPAM 
   —è–∑—ã–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è OCaml, –∫–æ—Ç–æ—Ä—É—é –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å –ø–æ–º–æ—â—å—é:</p>
   
<figure><code>$ opam install anders</code></figure>

<p>–í—ã –±—É–¥–µ—Ç–µ —É–¥–∏–≤–ª–µ–Ω—ã –ø—Ä–∏—è—Ç–Ω–æ–π –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å—é —è–∑—ã–∫–∞ Anders &mdash; –æ—Ç–∑—ã–≤—á–∏–≤–æ—Å—Ç—å—é
   –Ω–µ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å–±–æ—Ä–∫–µ –∏–∑ –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤:</p>

<figure><code>$ time dune build
real    0m1.456s
user    0m2.794s
sys     0m0.564s
</code></figure>

<p>–ù–æ –∏ —Å–∫–æ—Ä–æ—Å—Ç—å—é –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏:</p>

<figure><code>
$ time dune exec anders check library/book.anders

real    0m0.468s
user    0m0.051s
sys     0m0.032s
</code></figure>

<p>–ü—Ä–∏–º–µ—Ä –∫–æ–Ω—Å–æ–ª—å–Ω–æ–π —Å–µ—Å—Å–∏–∏ –∏ —Ä–∞–±–æ—Ç–∞ —Å –¥—ã—Ä–∞–º–∏:</p>

<figure><code>$ cat library/etale.anders
import library/infinitesimal

def is√âtaleMap (A B: U) (f: A -> B): U
 := isPullbackSq A (‚Ñë A) B (‚Ñë B) (‚Ñë-app A B f) (Œπ B) (Œπ A) f ?
</code></figure>

<figure><code>$ ./anders.native check library/etale.anders repl
Checking: is√âtaleMap
  
Hole:
  
A : U
B : U
f : A ‚Üí B
--------------------------------------------------------------------------------
Œ† (z : A), PathP (<_> ‚Ñë B) (‚Ñë-unit (f z)) (‚Ñë-unit (f z))
  
Checking: EtaleMap
File ‚Äúetale.anders‚Äù checked.

Anders theorem prover [MLTT][CCHM][HTS][deRham] version 1.1.1
>
</code></figure>

<P>–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –±–∞–∑–æ–≤–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏</P>

<figure><code>$ tree -L 3 .
‚îÇ
‚îú‚îÄ‚îÄ foundations
‚îÇ   ‚îÇ
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ mltt
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/mltt/bool.anders">bool.anders</a>
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/mltt/induction.anders">induction.anders</a>
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/mltt/either.anders">either.anders</a>
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/mltt/maybe.anders">maybe.anders</a>
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/mltt/nat.anders">nat.anders</a>
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/mltt/fin.anders">fin.anders</a>
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/mltt/vec.anders">vec.anders</a>
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/mltt/list.anders">list.anders</a>
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/mltt/mltt.anders">mltt.anders</a>
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/mltt/pi.anders">pi.anders</a>
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/mltt/sigma.anders">sigma.anders</a>
‚îÇ   ‚îÇ
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ univalent
‚îÇ¬†¬† ‚îÇ   ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/univalent/equiv.anders">equiv.anders</a>
‚îÇ¬†¬† ‚îÇ   ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/univalent/extensionality.anders">extensionality.anders</a>
‚îÇ¬†¬† ‚îÇ   ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/univalent/iso.anders">iso.anders</a>
‚îÇ¬†¬† ‚îÇ   ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/univalent/path.anders">path.anders</a>
‚îÇ¬†¬† ‚îÇ   ‚îî‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/univalent/prop.anders">prop.anders</a>
‚îÇ   ‚îÇ
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ modal
‚îÇ¬†¬†  ¬†¬† ‚îî‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/foundations/modal/infinitesimal.anders">infinitesimal.anders</a>
‚îÇ
‚îî‚îÄ‚îÄ mathematics
    ‚îÇ
    ‚îú‚îÄ‚îÄ categories
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/categories/abelian.anders">abelian.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/categories/category.anders">category.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/categories/functor.anders">functor.anders</a>
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/categories/groupoid.anders">groupoid.anders</a>
    ‚îÇ
    ‚îú‚îÄ‚îÄ homotopy
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/homotopy/coequalizer.anders">coequalizer.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/homotopy/constcubes.anders">constcubes.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/homotopy/hubSpokes.anders">hubSpokes.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/homotopy/pullback.anders">pullback.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/homotopy/pushout.anders">pushout.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/homotopy/quotient.anders">quotient.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/homotopy/suspension.anders">suspension.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/homotopy/KGn.anders">KGn.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/homotopy/S1.anders">S1.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/homotopy/Sn.anders">Sn.anders</a>
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/homotopy/truncation.anders">truncation.anders</a>
    ‚îÇ
    ‚îú‚îÄ‚îÄ geometry
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/geometry/bundle.anders">bundle.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/geometry/etale.anders">etale.anders</a>
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/geometry/formalDisc.anders">formalDisc.anders</a>
    ‚îÇ
    ‚îú‚îÄ‚îÄ meta
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/meta/awodey.anders">awodey.anders</a>
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/meta/favonia.anders">favonia.anders</a>
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/meta/kraus.anders">kraus.anders</a>
    ‚îÇ
    ‚îú‚îÄ‚îÄ algebra
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/algebra/algebra.anders">algebra.anders</a>
    ‚îÇ
    ‚îú‚îÄ‚îÄ analysis
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/analysis/real.anders">real.anders</a>
    ‚îÇ
    ‚îî‚îÄ‚îÄ topoi
        ‚îî‚îÄ‚îÄ <a href="https://github.com/groupoid/anders/blob/main/lib/mathematics/topoi/topos.anders">topos.anders</a>
</code></figure>


<h4>–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –∏–∑ –±–∞–∑–æ–≤–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏</h4>

<p>–ó–¥–µ—Å—å –∂–µ –ø—Ä–∏–≤–µ–¥–µ–Ω—ã –≤—ã–±—Ä–æ—á–Ω–æ —Ç–µ—Ä–º—ã –∏–∑ –º–æ–¥—É–ª–µ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
  –¥–ª—è –æ–∑–Ω–∞–∫–æ–º–ª–µ–Ω–∏—è —Å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–æ–º –∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏ —è–∑—ã–∫–∞.</p>

<figure><code>def pushout (A B C : U) (f : C ‚Üí A) (g : C ‚Üí B) : U
 := coequ C (+ A B) (‚àò C A (+ A B) (inl A B) f) (‚àò C B (+ A B) (inr A B) g)

def po‚ÇÅ (A B C: U) (f: C ‚Üí A) (g: C ‚Üí B) (a: A) : pushout A B C f g
 := Œπ C (+ A B) (‚àò C A (+ A B) (inl A B) f) (‚àò C B (+ A B) (inr A B) g) (inl A B a)

def po‚ÇÇ (A B C: U) (f: C ‚Üí A) (g: C ‚Üí B) (b: B)
  : pushout A B C f g
 := Œπ C (+ A B) (‚àò C A (+ A B) (inl A B) f) (‚àò C B (+ A B) (inr A B) g) (inr A B b)

def po‚ÇÉ (A B C: U) (f: C ‚Üí A) (g: C ‚Üí B) (c: C)
  : Path (pushout A B C f g) (po‚ÇÅ A B C f g (f c)) (po‚ÇÇ A B C f g (g c))
 := resp C (+ A B) (‚àò C A (+ A B) (inl A B) f) (‚àò C B (+ A B) (inr A B) g) c

def S¬π : U := coequ ùüè ùüè (id ùüè) (id ùüè)
def base : S¬π := Œπ ùüè ùüè (id ùüè) (id ùüè) ‚òÖ
def loop : Path S¬π base base := resp ùüè ùüè (id ùüè) (id ùüè) ‚òÖ 

def ùö∫ (A: U) : U := pushout ùüè ùüè A (const‚ÇÅ A) (const‚ÇÅ A)
def ùúé‚ÇÅ (A: U): ùö∫ A := po‚ÇÅ ùüè ùüè A (const‚ÇÅ A) (const‚ÇÅ A) ‚òÖ
def ùúé‚ÇÇ (A: U): ùö∫ A := po‚ÇÇ ùüè ùüè A (const‚ÇÅ A) (const‚ÇÅ A) ‚òÖ
def ùúé‚ÇÉ (A: U) (a: A) : Path (ùö∫ A) (ùúé‚ÇÅ A) (ùúé‚ÇÇ A) := po‚ÇÉ ùüè ùüè A (const‚ÇÅ A) (const‚ÇÅ A) a

def S : ‚Ñï ‚Üí U := ‚Ñï-iter U ùüê ùö∫

def trunc (A: U) (n: ‚Ñï): U := hs (S n) A
def trunc‚ÇÅ (A: U) (n: ‚Ñï) (x: A): trunc A n := center (S n) A x
def trunc‚ÇÇ (A: U) (n: ‚Ñï) (f: S n ‚Üí trunc A n) : trunc A n := hub (S n) A f
def trunc‚ÇÉ (A: U) (n: ‚Ñï) (f: S n ‚Üí trunc A n) (s : S n)
  : Path (trunc A n) (hub (S n) A f) (f s) := spoke (S n) A f s

def ‚Äñ_‚Äñ‚Çã‚ÇÅ (A : U) : U := trunc A zero -- Propositional Truncation ‚ÄñA‚Äñ‚Çã‚ÇÅ
def ‚Äñ_‚Äñ‚ÇÄ (A : U) : U := trunc A one   -- Set Truncation ‚ÄñA‚Äñ‚ÇÄ
def ‚Äñ_‚Äñ‚ÇÅ (A : U) : U := trunc A two   -- Groupoid Truncation ‚ÄñA‚Äñ‚ÇÅ
def ‚Äñ_‚Äñ (A : U) : ‚Ñï ‚Üí U := trunc A

def full (A : U) (R : A ‚Üí A ‚Üí U) := Œ£ (x y : A), R x y
def quot (A : U) (R : A ‚Üí A ‚Üí U)
 := coequ (full A R) A (Œª (w : full A R), w.1) (Œª (w : full A R), w.2.1)
def quot‚ÇÅ (A : U) (R : A ‚Üí A ‚Üí U) : A ‚Üí quot A R
 := Œπ (full A R) A (Œª (w : full A R), w.1) (Œª (w : full A R), w.2.1)
def quot‚ÇÇ (A : U) (R : A ‚Üí A ‚Üí U) (x y : A) (œÅ : R x y)
  : Path (quot A R) (quot‚ÇÅ A R x) (quot‚ÇÅ A R y)
 := resp (full A R) A (Œª (w : full A R), w.1) (Œª (w : full A R), w.2.1) (x, y, œÅ)

def ùö∫‚Çì (A: U) : ‚Ñï ‚Üí U := ‚Ñï-iter U A ùö∫
def discreteTopology (G : abgroup) : U := G.1.1
def R-K1 (G : group) : ùüè ‚Üí ùüè ‚Üí U := Œª (x y : ùüè), G.1.1
axiom Q-K1 (G : group) (x y : ùüè) (u w : R¬Ø ùüè (R-K1 G) x y) : U
 
def K1 (G : group) : U
 := ‚Äñ_‚Äñ‚ÇÅ (2-quot ùüè (R-K1 G) (Q-K1 G))
 
def K (G : abgroup) (n: ‚Ñï) : U
 := ‚Ñï-iter U (discreteTopology G) (Œª (_: U), ‚Äñ_‚Äñ (ùö∫‚Çì (K1 (G.X, G.2.g)) n) n) n

def algebra : U‚ÇÅ := Œ£
    -- a semicategory of contexts and substitutions:
    (Con: U)
    (Sub: Con ‚Üí Con ‚Üí U)
    (‚óä: Œ† (–ì Œò ‚àÜ : Con), Sub Œò ‚àÜ ‚Üí Sub –ì Œò ‚Üí Sub –ì ‚àÜ)
    (‚óä-assoc: Œ† (–ì Œò ‚àÜ –§ : Con) (œÉ: Sub –ì Œò) (Œ¥: Sub Œò ‚àÜ) (ŒΩ: Sub ‚àÜ –§),
       PathP (&lt;_>Sub –ì –§) (‚óä –ì ‚àÜ –§ ŒΩ (‚óä –ì Œò ‚àÜ Œ¥ œÉ)) (‚óä –ì Œò –§ (‚óä Œò ‚àÜ –§ ŒΩ Œ¥) œÉ))
    -- identity morphisms as identity substitutions:
    (id: Œ† (–ì : Con), Sub –ì –ì)
    (id-left: Œ† (Œò ‚àÜ : Con) (Œ¥ : Sub Œò ‚àÜ), Path (Sub Œò ‚àÜ) Œ¥ (‚óä Œò ‚àÜ ‚àÜ (id ‚àÜ) Œ¥))
    (id-right: Œ† (Œò ‚àÜ : Con) (Œ¥ : Sub Œò ‚àÜ), Path (Sub Œò ‚àÜ) Œ¥ (‚óä Œò Œò ‚àÜ Œ¥ (id Œò)))
    -- a terminal oject as empty context:
    (‚Ä¢: Con)
    (—î: Œ† (–ì : Con), Sub –ì ‚Ä¢)
    (‚Ä¢-Œ∑: Œ† (–ì: Con) (Œ¥: Sub –ì ‚Ä¢), Path (Sub –ì ‚Ä¢) (—î –ì) Œ¥)
    -- a presheaf of types:
    (Ty: Con ‚Üí U)
    (_|_|·µÄ: Œ† (–ì ‚àÜ : Con), Ty ‚àÜ ‚Üí Sub –ì ‚àÜ ‚Üí Ty –ì)
    (|id|·µÄ: Œ† (‚àÜ : Con) (A : Ty ‚àÜ), Path (Ty ‚àÜ) (_|_|·µÄ ‚àÜ ‚àÜ A (id ‚àÜ)) A)
    (|‚óä|·µÄ: Œ† (–ì ‚àÜ –§: Con) (A : Ty –§) (œÉ : Sub –ì ‚àÜ) (Œ¥ : Sub ‚àÜ –§),
    PathP (&lt;_>Ty –ì) (_|_|·µÄ –ì –§ A (‚óä –ì ‚àÜ –§ Œ¥ œÉ)) (_|_|·µÄ –ì ‚àÜ (_|_|·µÄ ‚àÜ –§ A Œ¥) œÉ))
    -- a (covariant) presheaf on the category of elements as terms:
    (Tm: Œ† (–ì : Con), Ty –ì ‚Üí U)
    (_|_|·µó: Œ† (–ì ‚àÜ : Con) (A : Ty ‚àÜ) (B : Tm ‚àÜ A) (œÉ: Sub –ì ‚àÜ), Tm –ì (_|_|·µÄ –ì ‚àÜ A œÉ))
    (|id|·µó: Œ† (‚àÜ : Con) (A : Ty ‚àÜ) (t: Tm ‚àÜ A),
        PathP (&lt;i> Tm ‚àÜ (|id|·µÄ ‚àÜ A @ i)) (_|_|·µó ‚àÜ ‚àÜ A t (id ‚àÜ)) t)
    (|‚óä|·µó: Œ† (–ì ‚àÜ –§: Con) (A : Ty –§) (t: Tm –§ A) (œÉ : Sub –ì ‚àÜ) (Œ¥ : Sub ‚àÜ –§),
       PathP (&lt;i> Tm –ì (|‚óä|·µÄ –ì ‚àÜ –§ A œÉ Œ¥ @ i))
             (_|_|·µó –ì –§ A t (‚óä –ì ‚àÜ –§ Œ¥ œÉ))
             (_|_|·µó –ì ‚àÜ (_|_|·µÄ ‚àÜ –§ A Œ¥) (_|_|·µó ‚àÜ –§ A t Œ¥) œÉ)), unit

def cc (A : U) (a : A) (p : Path A a a)
  : Cube A a a a a a a a a p p p p p p p p (cs A a p) (cs A a p) p p p p
    (cs A a p) (cs A a p) (cs A a p) (cs A a p)
 := &lt;k j i> hcomp A (‚àÇ i \/ ‚àÇ j \/ ‚àÇ k)
                    (Œª (l : I), [ (i = 0) -> c‚ÇÄ A a p @ l @ j @ k,
                                  (i = 1) -> c‚ÇÅ A a p @ l @ j @ k,
                                  (j = 0) -> c‚ÇÄ A a p @ l @ i @ k,
                                  (j = 1) -> c‚ÇÅ A a p @ l @ i @ k,
                                  (k = 0) -> c‚ÇÄ A a p @ l @ i @ j,
                                  (k = 1) -> c‚ÇÅ A a p @ l @ i @ j ])
                    (cb A a p @ i @ j @ k)

-- Definition (1) Dependent
def isFBundle1 (B: U) (p: B ‚Üí U) (F: U): U‚ÇÅ
 := Œ£ (_: Œ† (b: B), isContr (PathP (<_>U) (p b) F)), (Œ† (x: Sigma B p), B)
                    
-- Definition (2) Dependent
def isFBundle2 (B: U) (p: B ‚Üí U) (F: U): U
 := Œ£ (v: U) (w: surjective v B), (Œ† (x: v), PathP (<_>U) (p (w.1 x)) F)
                    
-- Definition (3) Non-Dependent
def im‚ÇÅ (A B: U) (f: A ‚Üí B): U := Œ£ (b: B), ||‚Çã‚ÇÅ (Œ† (a : A), Path B (f a) b)
def BAut (F: U): U := im‚ÇÅ ùüè U (Œª (x: ùüè), F)
def ùüè-Im‚ÇÅ (A B: U) (f: A ‚Üí B): im‚ÇÅ A B f ‚Üí B := Œª (x : im‚ÇÅ A B f), x.1
def ùüè-BAut (F: U): BAut F ‚Üí U := ùüè-Im‚ÇÅ ùüè U (Œª (x: ùüè), F)
def classify (E: U) (A' A: U) (E': A' ‚Üí U) (E: A ‚Üí U) (f: A' ‚Üí A): U
 := Œ† (x: A'), Path U (E'(x)) (E(f(x)))
def isFBundle3 (E B: U) (p: E ‚Üí B) (F: U): U‚ÇÅ
 := Œ£ (X: B ‚Üí BAut F), classify E B (BAut F) (Œª (b: B), fiber E B p b) (ùüè-BAut F) X
                    
-- Definition (4) Non-Dependent
def isFBundle4 (E B: U) (p: E ‚Üí B) (F: U): U‚ÇÅ
 := Œ£ (X: U) (v: surjective X B) (v': prod X F ‚Üí E),
      pullbackSq (prod X F) E X B p v.1 v' (Œª (x: prod X F), x.1)
         
def is√âtaleMap (A B: U) (f: A -> B): U
 := isPullbackSq A (‚Ñë A) B (‚Ñë B) (‚Ñë-app A B f)
                 (Œπ B) (Œπ A) f (\(a : A), &lt;i> ‚Ñë-naturality A B f a @ -i)
     
def EtaleMap (A B: U): U  := Œ£ (f: A -> B), is√âtaleMap A B f

def Family (B : U) : U‚ÇÅ := B ‚Üí U
def Fibration (B : U) : U‚ÇÅ := Œ£ (X : U), X ‚Üí B
 
def encode (B : U) (F : B ‚Üí U) (y : B) : fiber (Sigma B F) B (pr‚ÇÅ B F) y ‚Üí F y
 := Œª (x : fiber (Sigma B F) B (pr‚ÇÅ B F) y),
     subst B F x.1.1 y (&lt;i> x.2 @ -i) x.1.2
 
def decode (B : U) (F : B ‚Üí U) (y : B) : F y ‚Üí fiber (Sigma B F) B (pr‚ÇÅ B F) y
 := Œª (x : F y), ((y, x), idp B y)
 
def decode-encode (B : U) (F : B ‚Üí U) (y : B) (x : F y)
  : Path (F y) (transp (&lt;i> F (idp B y @ i)) 0 x) x
 := &lt;j> transp (&lt;i> F y) j x
 
def encode-decode (B : U) (F : B ‚Üí U) (y : B) (x : fiber (Sigma B F) B (pr‚ÇÅ B F) y)
  : Path (fiber (Sigma B F) B (pr‚ÇÅ B F) y) ((y, encode B F y x), idp B y) x
 := &lt;i> ((x.2 @ i, transp (&lt;j> F (x.2 @ i ‚à® -j)) i x.1.2), &lt;j> x.2 @ i ‚àß j)
 
def Bundle=Pi (B : U) (F : B ‚Üí U) (y : B)
  : PathP (&lt;_> U) (fiber (Sigma B F) B (pr‚ÇÅ B F) y) (F y)
 := isoPath (fiber (Sigma B F) B (pr‚ÇÅ B F) y) (F y)
    (encode B F y) (decode B F y) (decode-encode B F y) (encode-decode B F y)
</code></figure>

<h4>–ß–µ–≥–æ –Ω–µ—Ç –≤ Anders</h4>

<p>–í Anders –Ω–µ—Ç –æ–±—â–µ–π —Å—Ö–µ–º—ã –∏–Ω–¥—É–∫—Ç–∏–≤–Ω—ã—Ö —Ç–∏–ø–æ–≤ (data –∏ —Å–∏—Å—Ç–µ–º–∞ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤),
   –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç –∫—Ä–æ–º–µ –≤—Å–µ–≥–æ –ø—Ä–æ—á–µ–≥–æ –Ω–∞–ª–∏—á–∏–µ —á–µ–∫–µ—Ä–∞ –¥–ª—è –ø–æ–∑–∏—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Ç–∏–ø–æ–≤,
   —á–µ–∫–µ—Ä–∞ –¥–ª—è –∑–∞–≤–µ—Ä—à–∏–º–æ—Å—Ç–∏ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏, –∞ —Ç–∞–∫–∂–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∑–∞–¥–∞–Ω–∏—è
   –≤–∑–∞–∏–º–Ω–æ-—Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã—Ö —Ç–∏–ø–æ–≤. –°–µ–º–∞–Ω—Ç–∏–∫–∞ –ø–æ–ª–∏–Ω–æ–º–∏–∞–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ç–æ—Ä–æ–≤ W-—Ç–∏–ø–æ–≤
   –∏–º–µ–µ—Ç –±–æ–ª–µ–µ –∂–µ—Å—Ç–∫–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –Ω–∞ –≤—ã—Ä–∞–∑–∏–º–æ—Å—Ç—å. –ü–æ—ç—Ç–æ–º—É –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Ç–∏–ø—ã,
   —Ç–∞–∫–∏–µ –∫–∞–∫ K(G,n) –∏–ª–∏ –æ–±—â–∞—è —Å—Ö–µ–º–∞ n-—É—Å–µ—á–µ–Ω–∏–π —Ç—Ä–µ–±—É–µ—Ç –¥—Ä—É–≥–æ–≥–æ –±–∞–∑–∏—Å–∞.
   –¢–∞–∫–∂–µ –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –≤–∑–∞–∏–º–Ω–æ-—Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã—Ö —Ç–∏–ø–æ–≤ –≤ Anders –ø–æ–∫–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ
   –≤—ã—Ä–∞–∑–∏—Ç—å –≤—Å–µ–ª–µ–Ω–Ω—É—é –ú–∞—Ö–ª–æ –∏–ª–∏ –ø–æ–ª—É—Å–∏–º–ø–ª–∏—Ü–∏–∞–ª—å–Ω—ã–µ —Ç–∏–ø—ã (SST).
</p>

<h4>–î–∞–ª—å—à–µ–π—à–∏–µ –ø–ª–∞–Ω—ã</h4>

<p>–í –∫–∞—á–µ—Å—Ç–≤–µ —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞ —Å —Ç–∞–∫–æ–π –º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω–æ–π –∫—É–±–∏—á–µ—Å–∫–æ–π —Ç–µ–æ—Ä–∏–µ–π —Ç–∏–ø–æ–≤
   –º—ã —Ö–æ—Ç–∏–º –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—ã—Å—à–∏—Ö –∏–Ω–¥—É–∫—Ç–∏–≤–Ω—ã—Ö —Ç–∏–ø–æ–≤
   –∏—Å–ø–æ–ª—å–∑—É—è —Ç–æ–ª—å–∫–æ <b>W</b>, –∫–æ—ç–∫–≤–∞–ª–∞–π–∑–µ—Ä <b>coeq</b> –∏ –¥–≤—É—Ö–º–µ—Ä–Ω—ã–π —Å–ø–∏—Ü–µ–≤—ã–π –¥–∏—Å–∫ <b>hubSpokes</b> –≤
   –¥—É—Ö–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ HoTT –¥–ª—è Coq –∫–æ—Ç–æ—Ä—É—é –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –ú–∞–π–∫ –®—É–ª—å–º–∞–Ω.
</p>

<figure><code>type extension =
  | ECoeq of exp | EIota of exp | EResp of exp | EIndCoeq of exp
  | EDisc of exp | EBase of exp | EHub of exp | ESpoke of exp | EIndDisc of exp
</code></figure>

<p>–¢–∞–∫–∂–µ –≤ —Ñ–æ–∫—É—Å–µ –Ω–∞—à–µ–≥–æ –∏–Ω—Ç–µ—Ä–µ—Å–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –º–æ–¥—É–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Ç–∞–π–ø-—á–µ–∫–µ—Ä–∞,
  –º–æ—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º –≤–∫–ª—é—á–µ–Ω–∏–µ–º/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ–º —Ç–∏–ø–æ–≤
  –∏–ª–∏ –¥–∞–∂–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤ –≤ —Ä–∞–Ω-—Ç–∞–π–º–µ –¥–ª—è
  –ø–æ–ª–Ω–æ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—è –Ω–∞–±–æ—Ä–∞ –ø—Ä–∏–º–∏—Ç–∏–≤–æ–≤ —Ç–∞–π–ø—á–µ–∫–µ—Ä–∞ –∏ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è
  –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ç–µ–æ—Ä–µ—Ç–∏–∫–æ-—Ç–∏–ø–æ–≤—ã—Ö –±–∞–∑–∏—Å–æ–≤.</p>

<P>–¢—Ä–µ—Ç—å–µ–π —Ç–µ–º–æ–π –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–µ–ª–æ—Å—å –±—ã –ø–æ–¥–Ω—è—Ç—å –∑–¥–µ—Å—å &mdash; —ç—Ç–æ —Ç–∞–∫—Ç–∏–∫–∏.
   Anders –≤ –±—É–¥—É—â–µ–º –±—É–¥–µ—Ç –∏–º–µ—Ç—å Lean-–ø–æ–¥–æ–±–Ω—É—é —Å–∏—Å—Ç–µ–º—É —Ç–∞–∫—Ç–∏–∫.</P>

<p>–°–∏—Å—Ç–µ–º—ã —Ç–∏–ø–æ–≤ –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞–º–∏ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã:</p>

<p>
1. CoC (Coquand)<br>
2. MLTT (Martin-L√∂f)<br>
3. HoTT-I (Isaev)<br>
4. HoTT-‚àÇ (Siegment)<br>
5. Cubical (CCHM)<br>
6. HTS (Voevodsky)<br>
7. de Rham (Cherubini)<br>
</p>

<p>–°–∏—Å—Ç–µ–º—ã —Ç–∏–ø–æ–≤ –∫–æ—Ç–æ—Ä—ã–µ –º—ã —Ö–æ—Ç–∏–º –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å:</p>

<p>
1. Guarded Cubical (BBCGSV)<br>
2. Rezk (Riehl, Shulman)<br>
3. Equivariant Super HoTT (Schreiber)<br>
</p>

<h4>–í–º–µ—Å—Ç–æ –∑–∞–∫–ª—é—á–µ–Ω–∏—è</h4>

<p>–î–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –æ–∑–Ω–∞–∫–æ–º–ª–µ–Ω–∏—è —Å –ø—Ä—É–≤–µ—Ä–æ–º –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –≤–∞–º —Å–ª–µ–¥—É—é—â–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã:<br>
  &mdash; –î–æ–º–∞—à–Ω—è—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –ø—Ä–æ–µ–∫—Ç–∞: <a href="https://homotopy.dev/">–ì–æ–º–æ—Ç–æ–ø–∏—á–µ—Å–∫–∞—è —Å–∏—Å—Ç–µ–º–∞ —Ç–∏–ø–æ–≤.
          –ú–æ–¥–∞–ª—å–Ω–∞—è —Ç–µ–æ—Ä–∏—è —Ç–∏–ø–æ–≤ —Å –¥–≤—É–º—è —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞–º–∏, –µ–µ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∏ —Å–µ–º–∞–Ω—Ç–∏–∫–∞.</a><br>
  &mdash; <a href="https://github.com/groupoid/anders">–†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –ø—Ä–æ–µ–∫—Ç–∞</a> –Ω–∞ Github, –≥–¥–µ –≤—ã –º–æ–∂–µ—Ç–µ –æ—Å—Ç–∞–≤–∏—Ç—å –æ—Ç—á–µ—Ç—ã –æ–± –æ—à–∏–±–∫–∞—Ö<br>
  &mdash; –î—Ä—É–≥–∏–µ –≥–æ–º–æ—Ç–æ–ø–∏—á–µ—Å–∫–∏–µ –ø—Ä—É–≤–µ—Ä—ã Groupoid Infinity: <a href="https://cubical.systems">cubical.systems</a><br>
</p>


   <br><center>&dot;</center>

   <div id="utterances" class="utterances" > </div>
   <script src="https://utteranc.es/client.js" repo="5HT/tonpa.guru" issue-number="22" theme="github-light" crossorigin="anonymous" async> </script>

</section>
</main>
<footer>
  (19) Siegmentation Fault üßä Namdak Tonpa (41)</footer>
</body>
</html>