<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>2023-07-21 CMP/CMC/EST</title>
    <link rel="stylesheet" href="../../blank.css" />
    <link rel="stylesheet" href="../../journal.css?v=1" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2023-07-21</a>
</nav>
<main>
    <section>

    <h3>CMP/CMC/EST</h3>

    <p>Here is presented SYNRC –°A RA OCSP TSP TAMP SCVP server
       with CMP/CMC/EST enrollment protocols in Elixir.</p>

    <p>IETF follow up (PKIX):  7030, 6960, 6818, 6844, 6712, 6664, 6402,
       6277, 6170, 6024, 6025, 5934, 5912--5914, 5877, 5816, 5755, 5756,
       5758, 5697, 5636, 5480, 5272--5274, 5280, 5055, 5019, 4985, 4683,
       4630, 4476, 4387, 4325, 4158, 4210, 4211, 4055, 4043, 3874, 3779,
       3820, 3739, 3709, 3628, 3161, 3029, 2797, 2559, 2587, 3039, 3029,
       2511, 2510.</p>

    <figure><img src="https://authority.erp.uno/priv/design/ca-shaders.png"></figure>

    <p>Compatibility: OpenSSL, Cisco, Red Hat, Siemens, Nokia, IBM.</p>

    <h3>–í—Å—Ç—É–ø</h3>

    <p>–¶—è —Å—Ç–∞—Ç—Ç—è –º–æ–≥–ª–∞ –±–∏ –Ω–∞–∑–∏–≤–∞—Ç–∏ ¬´–Ø–∫ –Ω–∞–ø–∏—Å–∞—Ç–∏ CMP —Å–µ—Ä–≤–µ—Ä –∑–∞ 30 —Ö–≤–∏–ª–∏–Ω¬ª,
       –∞–ª–µ –Ω–∞ –≤—ñ–¥–º—ñ–Ω—É –≤—ñ–¥ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ—ó —Å—Ç–∞—Ç—Ç—ñ –ø—Ä–æ LDAP, —Ü—è –≤–∂–µ –ø–æ–∫—Ä–∏–≤–∞—î
       –±—ñ–ª—å—à–µ –Ω—ñ–∂ —Ç—É–∑—ñ–Ω—å ASN.1 —Ñ–∞–π–ª—ñ–≤, –¥–æ–±—Ä–µ —à–æ –º–∏ –≤–∂–µ –ø–æ–∑–Ω–∞–π–æ–º–∏–ª–∏—Å—è
       –∑ CMS —Ç–∞ LDAP –±—ñ–±—ñ–ª—ñ–æ—Ç–µ–∫–∞–º–∏ —Ç–∞ —ó—Ö ASN.1 —Ñ–∞–π–ª–∞–º–∏. –í —Ü—ñ–π —Å—Ç–∞—Ç—Ç—ñ –ø—Ä–æ CMP
       –Ω–∞—Å –≤ –æ—Å–Ω–æ–≤–Ω–æ–º—É —Ü—ñ–∫–∞–≤–∏—Ç–∏–º—É—Ç—å PKIXCMP-2009, PKIXCRMF-2009 —Ç–∞
       EnrollmentMessageSyntax-2009 –¥–ª—è CMC.</p>

<figure><code>CMS-AES-CCM-and-AES-GCM-2009.asn1
CMSAesRsaesOaep-2009.asn1
CMSECCAlgs-2009-02.asn1
CMSECDHAlgs-2017.asn1
CryptographicMessageSyntax-2009.asn1
CryptographicMessageSyntax-2010.asn1
CryptographicMessageSyntaxAlgorithms-2009.asn1
EnrollmentMessageSyntax-2009.asn1
PKCS-10.asn1
PKCS-7.asn1
PKIX1Explicit-2009.asn1
PKIX1Implicit-2009.asn1
PKIXAlgs-2009.asn1
PKIXCMP-2009.asn1
PKIXCRMF-2009.asn1</code></figure>

    <h3>CSR</h3>

    <p>–û—Ç–∂–µ –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –Ω–∞–ø–∏—Å–∞–Ω–Ω—è CMP —Å–µ—Ä–≤–µ—Ä—É –∑ –Ω–∞–π–≥–æ–ª–æ–≤–Ω—ñ—à–æ—ó –π–æ–≥–æ —Ñ—É–Ω–∫—Ü—ñ—ó:
       –≤–∏–¥–∞—á—ñ —Å–µ—Ä—Ç–∏—Ñ—ñ–∫–∞—Ç—É –ø–æ PCKS-10 CSR —Ä–µ–∫–≤–µ—Å—Ç—É. –°—Ö–µ–º–∞ –Ω–∞—Å—Ç—É–ø–Ω–∞:
       –ö–ª—ñ—î–Ω—Ç –≥–µ–Ω–µ—Ä—É—î –ø—Ä–∏–≤–∞—Ç–Ω–∏–π –∫–ª—é—á, –∫–æ–Ω–≤–µ—Ä—Ç—É—î –π–æ–≥–æ –≤ PEM —Ñ–∞–π–ª, –≤—ñ–¥—Å–∏–ª–∞—î —è–∫
       P10CR –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —É —Å–∫–ª–∞–¥—ñ payload PKIMessage, –æ—Ç—Ä–∏–º—É—î –≤—ñ–¥–ø–æ–≤—ñ–¥—å
       CP, –ø—ñ—Å–ª—è —á–æ–≥–æ –∫–ª—ñ—î–Ω—Ç —à–ª–µ —â–µ –æ–¥–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è CERTCONF, –ø—ñ—Å–ª—è
       —è–∫–æ–≥–æ CMP —Å–µ—Ä–≤–µ—Ä –ø–æ–≤–∏–Ω–µ–Ω –≤—ñ–¥–ø–æ–≤–∏—Å—Ç–∏ PKICONF –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º.</p>

<figure><code>  def csr(user) do
      {ca_key, ca} = read_ca()
      priv = X509.PrivateKey.new_ec(:secp384r1)
      der = :public_key.der_encode(:ECPrivateKey, priv)
      pem = :public_key.pem_encode([{:ECPrivateKey, der, :not_encrypted}])
      :file.write_file(user <> ".key", pem)
      :io.format '~p~n', [priv]
      csr = X509.CSR.new(priv, "/C=UA/L=Kyiv/O=SYNRC/CN=" <> user,
         extension_request: [
            X509.Certificate.Extension.subject_alt_name(["n2o.dev"])])
      :io.format 'CSR: ~p~n', [csr]
      :file.write_file(user <> ".csr", X509.CSR.to_pem(csr))
      true = X509.CSR.valid?(csr)
      subject = X509.CSR.subject(csr)
      :io.format 'Subject ~p~n', [subject]
      :io.format 'CSR ~p~n', [csr]
      X509.Certificate.new(X509.CSR.public_key(csr), subject, ca, ca_key,
         extensions: [subject_alt_name:
           X509.Certificate.Extension.subject_alt_name(["n2o.dev", "erp.uno"]) ])
      csr
  end</code></figure>

    <p>RFC2510</p>

    <P>–ü–µ—Ä–µ–¥ –ø–æ—á–∞—Ç–∫–æ–º —Ä–æ–±–æ—Ç–∏ CMP —Å–µ—Ä–≤–µ—Ä–∞ –ø–æ–≤–∏–Ω–µ–Ω –±—É—Ç–∏ –∑–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–∏–π —Ä—É—Ç–æ–≤–∏–π CA
       —Å–µ—Ä—Ç–∏—Ñ—ñ–∫–∞—Ç –∑ –ø—Ä–∏–≤–∞—Ç–Ω–∏–º –∫–ª—é—á–µ–º, —Ü—ñ –¥–≤–∞ —Ñ–∞–π–ª–∞ –º–∏ –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –Ω–∞ –¥–∏—Å–∫,
       —ñ —É –≤—Å—ñ—Ö –ø–æ–¥–∞–ª—å—à–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ—è—Ö –∫–æ—Ä–∏—Å—Ç—É—î–º–æ—Å—è –Ω–∏–º–∏. –î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó —Ñ–∞–π–ª—ñ–≤
       –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ñ—É–Ω–∫—Ü—ñ—é CA.CSR.ca.</p>

<figure><code>  def ca() do
      ca_key = X509.PrivateKey.new_ec(:secp384r1)
      ca = X509.Certificate.self_signed(ca_key,
            "/C=UA/L=Kyiv/O=SYNRC/CN=CSR-CMP", template: :root_ca)
      der = :public_key.der_encode(:ECPrivateKey, ca_key)
      pem = :public_key.pem_encode([{:ECPrivateKey, der, :not_encrypted}])
      :file.write_file "ca.key", pem
      :file.write_file "ca.pem", X509.Certificate.to_pem(ca)
      {ca_key, ca}
  end

  def read_ca() do
      {:ok, ca_key_bin} = :file.read_file "ca.key"
      {:ok, ca_bin} = :file.read_file "ca.pem"
      {:ok, ca_key} = X509.PrivateKey.from_pem ca_key_bin
      {:ok, ca} = X509.Certificate.from_pem ca_bin
      {ca_key, ca}
  end</code></figure>

     <p>–î–ª—è –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ—ó—ó –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó —Å–µ—Ä–≤–µ—Ä–Ω–∏—Ö —Å–µ—Ä—Ç–∏—Ñ—ñ–∫–∞—Ç—ñ–≤ —è–∫—ñ
        –æ–±—Å—É–≥–æ–≤—É—é—Ç—å –∫–ª—ñ—î–Ω—Ç—Å—å–∫—ñ TLS —Å–µ—Å—ñ—ó –º–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –∫–æ–¥.</p>

<figure><code>  def server(name) do
      {ca_key, ca} = read_ca()
      server_key = X509.PrivateKey.new_ec(:secp384r1)
        X509.Certificate.new(X509.PublicKey.derive(server_key),
           "/C=UA/L=Kyiv/O=SYNRC/CN=" <> name, ca, ca_key,
           extensions: [subject_alt_name:
              X509.Certificate.Extension.subject_alt_name(["n2o.dev", "erp.uno"]) ])
  end</code></figure>

    <h3>CMS</h3>

    <p>–î–µ—Ç–∞–ª—å–Ω–æ —Å—ñ–º–µ–π—Å—Ç–≤–æ –ø—Ä–æ—Ç–æ–∫–æ–ª—ñ–≤ —ñ CMS –∫–æ–¥—É–≤–∞–Ω–Ω—è –æ–ø–∏—Å–∞–Ω–æ –≤
       –æ–∫—Ä–µ–º—ñ–π —Å—Ç–∞—Ç—Ç—ñ –ø—Ä–∏—Å–≤—è—á–µ–Ω—ñ–π <a href="2023-07-16 CMS Compliance.htm">CMS Compliance</a>.
       CMS –∫–æ–¥—É–≤–∞–Ω–Ω—è –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —Ç—ñ–ª—å–∫–∏ –¥–ª—è CMC —Å–µ—Ä–≤–µ—Ä–∞, —Ç–æ–º—É
       –º–∏ —Ü–µ –ø–æ–∫–∏ –≤–∏—Å–≤—ñ—Ç–ª—é–≤–∞—Ç–∏ –Ω–µ –±—É–¥–µ–º–æ.</p>

    <h3>CMP/CSR/TCP</h3>

    <p>RFC 6712, 4210. –î–ª—è –ø–æ—á–∞—Ç–∫—É –Ω–∞–ø–∏—à–µ–º–æ –ø—Ä–æ—Å—Ç–∏–π PKIMessage —Å–µ—Ä–≤–µ—Ä.</p>

<figure><code>
defmodule CA.CMP do
  @moduledoc "CA/CMP TCP server."
  require CA

  def start(), do: :erlang.spawn(fn -> listen(1829) end)
  def listen(port) do
      {:ok, socket} = :gen_tcp.listen(port,
        [:binary, {:packet, 0}, {:active, false}, {:reuseaddr, true}])
      accept(socket)
  end

  def accept(socket) do
      {:ok, fd} = :gen_tcp.accept(socket)
      :erlang.spawn(fn -> __MODULE__.loop(fd) end)
      accept(socket)
  end

  def loop(socket) do
      case :gen_tcp.recv(socket, 0) do
           {:ok, data} ->
               [headers,body] = :string.split data, "\r\n\r\n", :all
               {:ok,dec} = :'PKIXCMP-2009'.decode(:'PKIMessage', body)
               {:PKIMessage, header, body, code, _extra} = dec
               __MODULE__.message(socket, header, body, code)
               loop(socket)
          {:error, :closed} -> :exit
      end
  end

</code></figure>

    <h4>PKIMessage.protection</h4>

    <p>–†–æ–∑–±–µ—Ä–µ–º–æ—Å—è –∑ –ø–æ–ª–µ–º PKIMessage.protection, –≤ —è–∫–æ–º—É
       –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç PBKDF2 –∞–ª–≥–æ—Ä–∏—Ç–º–∞. –ú–∞–π—Ç–µ –Ω–∞ —É–≤–∞–∑—ñ
       —à–æ OpenSSL –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î 20-–±–∞–π—Ç–Ω—ñ –∫–ª—é—á—ñ
       —Ç–∞ HMAC/SHA-1 —É —è–∫–æ—Å—Ç—ñ MAC —Ñ—É–Ω–∫—Ü—ñ—ó, —Ö–æ—á–∞ OWF –≤ 500 —ñ—Ç–µ—Ä–∞—Ü—ñ—è—Ö
       –æ–±—á–∏—Å–ª—é—î—Ç—å—Å—è –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é OWF —Ñ—É–Ω–∫—Ü—ñ—ó SHA-256.</p>

<figure><code>
  def baseKey(pass, salt, iter, owf \\ :sha256), do:
      :lists.foldl(fn _, acc ->
      :crypto.hash(owf, acc) end, pass <> salt,
      :lists.seq(1,iter))

  def protection(:asn1_NOVALUE), do: {"","","","",1}
  def protection(protectionAlg) do
      {_,oid,{_,param}} = protectionAlg
      {:ok, parameters} = :"PKIXCMP-2009".decode(:'PBMParameter', param)
      {:PBMParameter, salt, {_,owf,_}, counter, {_,mac,_} } = parameters
      {oid, salt, owf, mac, counter}
  end

  def validateProtection(header, body, code) do
      {:PKIHeader, _, _, _, _, protectionAlg, _, _, _, _, _, _, _} = header
      {oid, salt, owfoid, _mac, counter} = protection(protectionAlg)
      case CA.ALG.lookup(oid) do
           {:'id-PasswordBasedMac', _ } ->
                protection = CA."ProtectedPart"(header: header, body: body)
                {:ok, bin} = :"PKIXCMP-2009".encode(:'ProtectedPart', protection)
                {owf,_} = CA.ALG.lookup(owfoid)
                pbm = :application.get_env(:ca, :pbm, "0000")
                verifyKey  = baseKey(pbm, salt, counter, owf)
                mac = CA.KDF.hs(:erlang.size(code))
                :crypto.mac(:hmac, mac, verifyKey, bin)
           {_, _ } ->
                ""
      end
  end
</code></figure>

    <h4>ANSWER</h4>

    <P>–û—Å–∫—ñ–ª—å–∫–∏ CMP —Å–µ—Ä–≤–µ—Ä –ø–æ–≤–∏–Ω–µ–Ω –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ –ø–æ HTTP/1.0
       –∑–≥—ñ–¥–Ω–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ñ–≤ –¥–æ–¥–∞—î–º–æ –Ω–µ–æ–±—Ö—ñ–¥–Ω—ñ HTTP –∑–∞–≥–æ–ª–æ–≤–∫–∏.</p>

<figure><code>
  def answer(socket, header, body, code) do
      message = CA."PKIMessage"(header: header, body: body, protection: code)
      {:ok, bytes} = :'PKIXCMP-2009'.encode(:'PKIMessage', message)
      res =  "HTTP/1.0 200 OK\r\n"
          <> "Server: SYNRC CA/CMP\r\n"
          <> "Content-Type: application/pkixcmp\r\n\r\n"
          <> :erlang.iolist_to_binary(bytes)
      :gen_tcp.send(socket, res)
  end
</code></figure>

    <h4>P10CR/CP</h4>

    <p>–ó–∞–ø—É—Å–∫–∞—î–º–æ —Å–µ—Ä–≤–µ—Ä —Ç–∞ –≥–µ–Ω–µ—Ä—É—î–º–æ —Å–µ—Ä—Ç–∏—Ñ—ñ–∫–∞—Ç–∏ CA —Ç–∞ CSR –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞:</p>

<figure><code>$ mix deps.get
$ iex -S mix
> CA.CSR.ca
> CA.CSR.csr "maxim"
</code></figure>

    <p>–ó–∞–ø—É—Å–∫–∞—î–º–æ –∫–ª—ñ—î–Ω—Ç—Å—å–∫–∏–π –∑–∞–ø–∏—Ç –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é OpenSSL:</p>

<figure><code>
# openssl cmp -cmd p10cr -server localhost:1829 \
#             -path . -srvcert ca.pem -ref cmptestp10cr \
#             -secret pass:0000 -certout $client.pem -csr $client.csr
</code></figure>

    <p>–ü–∏—à–µ–º—É —Ñ—É–Ω–∫—Ü—ñ—é –≤–∏–¥–∞—á—ñ —Å–µ—Ä—Ç–∏—Ñ—ñ–∫–∞—Ç—É:</p>

<figure><code>
  def message(socket, header, {:p10cr, csr} = body, code) do
      {:PKIHeader, pvno, from, to, messageTime, protectionAlg,
         _senderKID, _recipKID, transactionID, senderNonce,
         _recipNonce, _freeText, _generalInfo} = header
      true = code == validateProtection(header, body, code)

      {ca_key, ca} = CA.CSR.read_ca()
      subject = X509.CSR.subject(csr)
      :io.format '~p~n',[subject]
      true = X509.CSR.valid?(CA.parseSubj(csr))
      cert = X509.Certificate.new(X509.CSR.public_key(csr),
         CA.CAdES.subj(subject), ca, ca_key,
         extensions: [subject_alt_name:
            X509.Certificate.Extension.subject_alt_name(["synrc.com"]) ])

      reply = CA."CertRepMessage"(response:
            [ CA."CertResponse"(certReqId: 0,
              certifiedKeyPair: CA."CertifiedKeyPair"(certOrEncCert:
                {:certificate, {:x509v3PKCert, CA.convertOTPtoPKIX(cert)}}),
              status: CA."PKIStatusInfo"(status: 0))])

      pkibody = {:cp, reply}
      pkiheader = CA."PKIHeader"(sender: to, recipient: from, pvno: pvno,
          recipNonce: senderNonce, transactionID: transactionID,
          protectionAlg: protectionAlg, messageTime: messageTime)
      answer(socket, pkiheader, pkibody,
          validateProtection(pkiheader, pkibody, code))
  end</code></figure>

    <h4>CERTCONF/PKICONF</h4>

<figure><code>  def message(socket, header, {:certConf, statuses}, code) do
      {:PKIHeader, _, from, to, _, _, _, _, _, senderNonce, _, _, _} = header

      :lists.map(fn {:CertStatus,bin,no,{:PKIStatusInfo, :accepted, _, _}} ->
          :logger.info 'CERTCONF ~p request ~p~n', [no,:binary.part(bin,0,8)]
      end, statuses)

      pkibody = {:pkiconf, :asn1_NOVALUE}
      pkiheader = CA."PKIHeader"(header, sender: to, recipient: from,
          recipNonce: senderNonce)
      answer(socket, pkiheader, pkibody,
          validateProtection(pkiheader, pkibody, code))
  end</code></figure>

    <p>–í —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ –≤ –∫–æ–Ω—Å–æ–ª—ñ –ø–æ–≤–∏–Ω–Ω—ñ —Å–ø–æ—Å—Ç–µ—Ä—ñ–≥–∞—Ç–∏:</p>

<figure><code>CMP info: sending P10CR
CMP info: received CP
CMP info: sending CERTCONF
CMP info: received PKICONF
CMP info: received 1 enrolled certificate(s), saving to file 'maxim.pem'
</code></figure>

    <h4>GENM/GENP</h4>

    <p>–î–∞–ª—ñ –º–æ–∂–µ—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç–∏ —ñ–Ω—à—ñ —Ñ—É–Ω–∫—Ü—ñ—ó:</p>

<figure><code># openssl cmp -cmd genm -server 127.0.0.1:1829 \
#             -recipient "/CN=CMPserver" -ref 1234 -secret pass:0000</code></figure>

<figure><code>  def message(_socket, _header, {:genm, req} = _body, _code) do
      :io.format 'generalMessage: ~p~n', [req]
  end</code></figure>

    <h4>IR/IP</h4>

<figure><code># openssl cmp -cmd ir -server 127.0.0.1:1829 \
#             -path . -srvcert ca.pem -ref NewUser \
#             -secret pass:0000 -certout maxim.pem \
#             -newkey maxim.key -subject "/CN=maxim/O=SYNRC/ST=Kyiv/C=UA"</code></figure>

<figure><code>  def message(_socket, _header, {:ir, req}, _) do
      :lists.map(fn {:CertReqMsg, req, sig, code} ->
         :io.format 'request: ~p~n', [req]
         :io.format 'signature: ~p~n', [sig]
         :io.format 'code: ~p~n', [code]
      end, req)
  end</code></figure>

    <h4>CR/CP</h4>

<figure><code># openssl cmp -cmd cr -server 127.0.0.1:1829 \
#             -path . -srvcert ca.pem -ref NewUser \
#             -secret pass:0000 -certout maxim.pem \
#             -newkey maxim.key -subject "/CN=maxim/O=SYNRC/ST=Kyiv/C=UA"</code></figure>

<figure><code>
</code></figure>

    <h3>CMC/CMS/TCP</h3>

    <p>RFC 5272--5274, 2797, 6402.</p>

    <h3>EST/CMS/TLS</h3>

    <p>RFC 7030</p>

    <h3>–í–∏—Å–Ω–æ–≤–∫–∏</h3>


<figure><code>defmodule CA do
  use Application
  use Supervisor

  require Record
  Enum.each(Record.extract_all(from_lib: "ca/include/PKIXCMP-2009.hrl"),
            fn {name, definition} -> Record.defrecord(name, definition) end)

  Enum.each(Record.extract_all(from_lib: "public_key/include/public_key.hrl"),
            fn {name, definition} -> Record.defrecord(name, definition) end)

  def init([]), do: {:ok, { {:one_for_one, 5, 10}, []} }
  def start(_type, _args) do
      :logger.add_handlers(:ldap)
      CA.CMP.start
      CA.CMC.start
      :supervisor.start_link({:local, __MODULE__}, __MODULE__, [])
  end
end</code></figure>

    <p>–ù—É PasswordBasedMac –≤ –Ω–∞—Å —î, —Ç–µ–ø–µ—Ä —Ç—Ä–µ–±–∞ DHMac, –∞–ª–µ shared secret
       –º–æ–∂–Ω–∞ —ñ –≤ PBM –∑–∞—Å—É–Ω—É—Ç–∏. –Ñ —à–µ Proof Of Posession (POP) ‚Äî —Ç–∞–º –∑—Ä–∞–∑—É
       ECDSA verify. –Ø –¥–æ —Ä–µ—á—ñ –¥—É–º–∞—é –≤ CA —Ç—Ä–∏–º–∞—Ç–∏ –∫–ª—é—á—ñ –¥–ª—è –≤—Å—ñ—Ö –∫—Ä–∏–≤–∏—Ö,
       —ñ –∫–æ–ª–∏ —è –≤–∏—Å—Ç–∞–≤–ª—è—Ç–∏–º—É —Å–µ—Ä–≤—ñ—Å —Ç–æ —è –±—É–¥—É –≤–∏—Å—Ç–∞–≤–ª—è—Ç–∏ –π–æ–≥–æ –Ω–∞ N –ø–æ—Ä—Ç–∞—Ö
       —ñ N –∫–ª—é—á–∞—Ö, —â–æ–± –±—É–¥—å —è–∫–∏–π –∫–ª—ñ—î–Ω—Ç—Å—å–∫–∏–π TLS —Å–µ—Ä—Ç–∏—Ñ—ñ–∫–∞—Ç –ø—Ä–∏–π–º–∞–≤—Å—è —è–∫ —Ä—ñ–¥–Ω–∏–π!
       Chat üí¨ X.509 –¥–∞—î –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –≤–∏–±–∏—Ä–∞—Ç–∏ TLS —Å–µ—Ä—Ç–∏—Ñ—ñ–∫–∞—Ç–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–æ
       –æ–±—Ä–∞–Ω–∏—Ö –∫—Ä–∏–≤–∏—Ö. –í–∏ –≤–∏–±–∏—Ä–∞—î—Ç–µ –ø—ñ–¥ —è–∫–∏–º–∏ –∫–ª—é—á–∞–º–∏ —Å—å–æ–≥–æ–¥–Ω—ñ –∑–∞—Ö–æ–¥–∏—Ç–∏.
       LDAP, MQTT, NS, CA ‚Äî –≤ –∫–æ–∂–Ω–æ–≥–æ —Å–µ—Ä–≤—ñ—Å—É —Å–≤–æ—ó N –ø–æ—Ä—Ç—ñ–≤ —ñ N —Å–µ—Ä–≤–µ—Ä–Ω–∏—Ö
       TLS —Å–µ—Ä—Ç–∏—Ñ—ñ–∫–∞—Ç—ñ–≤. –ü–µ—Ä–µ–¥–±–∞—á–∞—î—Ç—å—Å—è —â–æ –ø–µ—Ä—à–∏–π —Å–µ—Ä—Ç–∏—Ñ—ñ–∫–∞—Ç –≤–∏–¥–∞—î—Ç—å—Å—è DH
       –ø–æ TCP –∞ –ø–æ—Ç—ñ–º –∑—Ä–∞–∑—É –≤—Å—å–æ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –≤ TLS —Ä–µ–∂–∏–º —ñ –≤—Å—ñ –Ω–∞—Å—Ç—É–ø–Ω—ñ
       —Å–µ—Ä—Ç–∏—Ñ—ñ–∫–∞—Ç–∏ –≤–∂–µ –≤–∏–¥–∞—é—Ç—å—Å—è –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ –∫–ª—ñ—î–Ω—Ç—Å—å–∫–æ–≥–æ TLS. –ü—Ä–∏ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó
       –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –∑—Ä–∞–∑—É –¥–æ—Å—Ç—É–ø–Ω–∏–π –≤ LDAP —è–∫—à–æ –∑–∞—Ö–æ—Ç—ñ–≤ –∑—Ä–æ–±–∏—Ç–∏ —Å–µ–±–µ –≤—ñ–¥–∫—Ä–∏—Ç–∏–º
       –¥–ª—è –ø–æ—à—É–∫—É. –ü—ñ—Å–ª—è —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó –ø–æ—à—É–∫ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó —ñ —Ñ—Ä–µ–Ω–¥—É–≤–∞–Ω–Ω—è (–æ–±–º—ñ–Ω
       –∫–ª—é—á–∞–º–∏) —ñ –ø–æ—ó—Ö–∞–ª–∏ —á–∞—Ç –≤ –æ–±–≥–æ—Ä—Ç–∫–∞—Ö CAdES, CMS, ECDSA/AES ‚Äî –ª–µ–π–±–∏ –±—ñ–ª—è
       –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –ü–Ü–î–ü–ò–°/–®–ò–§–†.</p>

   <br><center>&dot;</center>

    <hr>

   <br><center>&dot;</center>

     <p>
     [1]. <a href="https://www.cisco.com/c/dam/en_us/about/doing_business/trust-center/docs/public-key-infrastructure-provisioning-with-est.pdf">Cisco. PKI: Simplify Certificate Provisioning with EST. 2016</a><br>
     [2]. <a href="https://authority.erp.uno">SYNRC CA</a><br>
     </p>

    </section>
</main>
<footer><a href="https://instagram.com/5HT/">Namdak T√∂npa</a> <span class="heart">&nbsp;‚ù§&nbsp;</span> 2023</footer>
</body>
</html>

