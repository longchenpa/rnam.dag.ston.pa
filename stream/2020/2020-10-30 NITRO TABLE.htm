<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Namdak Tonpa" />
    <title>2019-10-30</title>
    <link rel="stylesheet" href="../../blank.css" />
    <link rel="stylesheet" href="../../journal.css" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2019-10-30</a>
</nav>
<main>
  <article>
    <section>
     <h3>NITRO: Таблиці</h3>

      <p><b>Категорії: дизайн та імплементація контрольних елементів NITRO,
            технічне завдання.</b></p>

      <p>Ми вже показали в <a href="https://tonpa.guru/stream/2019/2019-10-09%20NITRO%20UI.htm">попередній статті</a>,
         як проходить формальна розробка контрольного елементу NITRO на прикладі <b>#comboLookup</b>. У цій статті хочемо
         навести інший приклад, фундаментального з точки зору ERP систем, контрольного елементу
         для дистанційного відображення відсортованого датасету на стороні сервера за
         допомогою тонкого клієнта та реактивного протоколу. На цей раз покажемо
         процес розробки контрольного елменту у повному виробничому циклі.</p>

     <h4>Загальний цикл розробки контрольних елементів</h4>

     <p>Створення контрольних елементів поділяється на три етапи:</p>

     <p>1) Створення ТЗ з функціональними вимиогами та мотивацією;<br/>
        2) Технічна специфікація, модель та імплементація Erlang/Elixir/JS;<br/>
        3) Документування на офіційних сторінках NITRO.<br/></p>

     <h4>1. Технічне завдання</h4>

     <p><b>Основна мотивація.</b> Створення контрольного UI елемента для
        відображення відсортованих великих датасетів у табличному
        вигляді на стороні тонкого клієнта з контрольованим курсором
        на стороні сервера.</p>

     <p>Основною мотивацією створення такого спрощеного елементу
        є елімінація будь-яких видів сортувань як на стороні клієнта так і сервера.
        Для імплементації класичної вимоги до табличних контрольних
        елементів &mdash; сортування колонок, застосовується набів уже
        відсортованих за певним критерієм (колонкою) списків об'єктів.
        Кожен об'єкт який попадає в основний датасет проходить
        реіндексацію згідно усіх критеріїв. Цей підхід дозволяє значно спростити архітектуру
        реєстрових таблиць як на стороні клієнта так і на стороні сервера (відсутність кешу
        на клієнті та повна відсутність сортувань), при цьому користува отримує
        безпосередній доступ до курсора на стороні сервера.</p>

     <p>Для забезпечення складних випадків, коли (мульти)-індекси важко або неможливо
        побудувати засобами сховища (лімітовані розподілені KV сховища), сортування відбувається
        функціями користувача які занадто дорого реіндексувати. Використовується
        інший механізм пошуку, а саме пошук за допомогою асинхронних пошукових воркерів.
        Для певного несортованого фіду запускається пошуковий процес, який послідовно перебирає
        усі об'єкти сховища, знаходить відповідні до критерію пошуку, та асинхронно передає їх на клієнт.
        У випадку коли клієнт покидає сторінку або починає новий пошук,
        пошуковий процес повинен завершитися. Цей підхід уже апробований
        та добре себе зарекомендував для швидкого прототипування довільних
        таблиць та правил пошуку та сортування часу виконання на стороні сервера.</p>

     <p><b>Функціональні вимоги.</b> Основні вимоги, які не залежать від вибору технології реалізації:<br>
        — Робота у вікні фіксованої висоти у рядках;<br>
        — Обмеження швидкості реакції відповіді (backpressure);<br>
        — Автоматична робота по відсортованих джерелах даних;<br>
        — Мінамальний розмір клієнтського та серверного коду;<br>
        — Підтримка пошукових асинхронних процесів;<br>
        — Відсутність горизонтального скролу таблиці;<br>
        — Повний контроль за допомогою клавіатури;<br>
        — Базовий протокол: init, seek, next, prev.<br>
       </p>

     <h4>2. Дизайн та імплементація</h4>

     <p>Оскільки ТЗ було складене для імплементації контрольного елменту NITRO,
        формальна модель та специфікація буде надаватися на мові Erlang.</p>

     <p>Техноробочий проект NITRO TABLE пропонується опублікувати
        на <a href="https://github.com/gor-che/tpage">Github</a> для виконавця.</p>

     <p>1) Створення ТЗ з функціональними вимиогами та мотивацією;<br/>
        2) Технічна специфікація, модель та імплементація Erlang/Elixir/JS;<br/>
        3) Документування на офіційних сторінках NITRO.<br/></p>

     <h4>3. Документування та тестування</h4>

     <p>Контрольний елемент повинен відповідати рівню Г5, у номенклатурі рівнів відповідності КЗЗ,
        як визначено документом НД ТЗІ 2.5-004-99. Тому повна формальна специфікація усіх
        об'єктів, їх зв'язків з відповідними протоколами повинні бути повністю визначені в документації,
        так само як і доведення властивостей моделі та її коректності на всіх наборах даних.
        Головним критерієм відповідності нормативам КЗЗ — це жорсткий контроль перфікса
        дерева по якому відбувається пошук, так як вихід за його межі означає порушення
        системи захисту інформації.</p>

     <p>Після формального визначення об'єктів та протоколів в man/index.htm,
        контрольний документ публікується в <a href="https://github.com/synrc/storybook">Storyboard
        контрольних елементів NITRO</a>.</p>

     <p>Для автоматизації тестування UI слід використовувати <a href="https://www.casperjs.org/">casper.js</a></p>

     <h4>Додаток 1</h4>

     <p>Перелік функцій на стороні JavaScript для реалізаціі
        мінімального клієнта N2O NITRO протоколу:</p>

     <p>token() — поточний токен сесії<br/>
        qi(name) — DOM елемент по існуючому id<br/>
        qs(name) — пошук DOM елементу<br/>
        qn(name) — створення нового DOM елементу<br/>
        is(x, num, name)<br/>
        co(name) — отримання cookies (застаріло, використувуємо localStorage)<br/>
        querySource(name) — отримання преформатованої змінної поля value<br/>
        validateSources(list) — провалідувати поле value для списку елементів<br/>
        N2O_start() — створення веб-сокет каналу<br/>
        $bert — реалізація бінарного берт протоколу на JavaScript<br/>
        $io — IO протокол (евалуатор та помилки)<br/>
        $file — FTP протокол (трансфер великих файлів до 100ГБ)<br/>
        $ws — вебсокет транспорт<br/>
        transports — транспорти<br/>
        protos — протоколи<br/>
        </p>

        <br/>
        <hr/>
        <br/>

     <p>— <a href="https://n2o.dev/deps/nitro/man/ua/index.html">NITRO</a> — Загальна інформація про веб-фреймворк NITRO<br/>
        — <a href="https://n2o.dev/deps/n2o/man/ua/index.html">N2O</a> — Опис контейнера протоколів та сервісів N2O<br/>
        — <a href="https://n2o.dev/deps/n2o/man/ua/n2o_nitro.htm">N2O NITRO</a> — Опис протоколу веб-фреймворку<br/>
        — <a href="https://n2o.dev/deps/n2o/man/ua/bert.js.htm">BERT.JS</a> — Опис бінарного протоколу<br/></p>
    </section>
  </article>
</main>
<footer>Namdak Tonpa <span class="heart"> ❤ </span> SYNRC</footer>
</body>
</html>
