<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>2021-08-09</title>
    <link rel="stylesheet" href="https://n2o.dev/blank.css" />
    <link rel="stylesheet" href="../../journal.css" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2021-08-09</a>
</nav>
<main>
    <section>
        <h3>TWAIN 2: Д'Артаньян 20 лет спустя</h3>

        <p>TLDR; Сохацкий опять за неделю ебанул нетленочку.</p>

        <p>Как вы знаете в 2001 году первоей моей работой в международной компании на 3-м курсе КПИ
           была корпорация International Land Systems, Inc., где мы писали
           системы сканирования, хранения и управления бизнес-процессами для автоматизации
           документооборота в кадастровом деле для таких стран как Ямайка, Египет, Азербайджан (на уровне министерств).
           Также вы можете знать со страниц этого блога, что делалось это на самописном <a href="https://github.com/devaspot/lisp">LISP</a>
           для (тогда еще) .NET Framework 1.0.</p>

        <p>И вот, спустя 20 лет, оказывается ситуация на рынке совсем не изменилась.
           Сканеры по-прежнему не умеют сканировать в браузеры, поэтому такие производители
           как LeadTools (библиотеку которых я использовал тогда) или
           Dynamsoft (которую мы пытались использовать сейчас)
           предлагают свои решения для обеспечения доставки отсканированых изображений в контекст
           веб-браузера посредством промежуточного локального веб-сервера имеющего доступ
           к физическому устройству TWAIN. И решения эти, надо сказать, слишком дорогие
           для <a href="https://dir.gov.ua/projects/sev-ovv/perel-k-protestovanikh-sed">производителей
           СЭД на рынке Украины</a>, где выставлена более-менее унифицированая цена СЭД в около тыщи долларов за год,
           а стоимость решений для сканирования начинается только в пол цены от этого!
           Поэтому все они должны использовать свои решения для сканирования.</p>

        <figure><img src="https://github.com/erpuno/scan/raw/master/Resources/screenshot.png"></figure>

        <p>Наш продукт "МІА: Документообіг" состоит из трех суб-продуктов: 1) <b>"МІА: CRM"</b> (ядро CRM системы,
           на базе которого построена СЭД), 2) <b>"МІА: Офіс"</b> &mdash; система редактирования офисных документов Word, Excel, PowerPoint (OpenXML SDK) для браузера,
           3) <b>"МІА: Сканування"</b> &mdash; система захвата изображений из сканера в браузер, а также приложение в области уведомлений для получения документов с бекендов,
           и именно о нем пойдет речь в этой статье.</p>

        <h4>Формирование требований и компоненты архитектуры</h4>

        <p>Предварительные исследования показали, что все заказчики Украины на рынке СЭД хотят трей приложение
           для трех систем (Mac, Linux, Windows), которое бы одновременно: 1) выступало и локальным
           сервером для браузера, который имеет доступ к цифровым ключам, сканерам, и другим устройствам,
           и обслуживает запросы со страницы приложения "МІА: Документообіг" и 2) было MQTT клиентом,
           соединялось с брокером сообщений и подписывалось для получения различных оповещений
           реального времени по заданным каналам подписок. Для реализации первой части нами в январе был
           написан F# (потому, что мы уже не дети, чтобы писать на LISP) WebSocket сервер,
           лайки которому ставил Филипп Картер, когда еще был програмным
           менеджером F# в Microsoft. Вторая часть просто использует NuGet библиотеку System.Net.Mqtt и
           конектится к брокеру EMQ X, который является опциональной частью поставки "МІА: Документообіг".</p>

        <figure><img src="https://github.com/erpuno/scan/raw/master/Resources/messaging.png"></figure>

        <p>Также основным приоритетным требованием кроме кросслпатформенности является получение сразу PDF документов,
           поэтому в поставку была включена достаточно небольшая библиотека PDFSharp (700KB).</p>

        <p>* Kodak Alaris C# TWAIN SDK (256KB)<br>
           * Empira C# PDF SDK (700KB)<br>
           * INFOTECH F# WebSocket server (64KB)<br>
           * Xamarin C# MQTT client (160KB)</p>

        <p>Что касается самого главного, TWAIN SDK, то тут сразу есть два варианта:
           писать все самому на С++ (дорого) или писать все самому на .NET (дешево).
           Сейчас официальный TWAIN SDK который лежит у них на Github написано компанией KODAK Alaris,
           поэтому я взял их примеры и начал работать. Структура их примеров содержит три проекта,
           в каждом из которых содержится имплементация одного из режимов работы сканера:
           1) Memory Transfer;
           2) Native Transfer;
           3) File Transfer. Но ни один из этих проектов не содержит код который
           можно использовать прямо, однако там достаточно того, чтобы понять что происходит.</p>

        <p>Я сразу начал с Memory режима и сразу получил стабильные артефакты
           при неопределенных обстоятельствах. Потратив день на эту проблему, я быстро переключился
           на Native режим и еще за один день полностью переписал сканирование на него,
           добавив дуплексное сканирование и автоподачу с фидера (автосканирование). Получив прототип
           стабильного сканирования я создал прослойку из хелперов для достаточно наивного
           студенческого Kodak Alaris SDK. Я пытался получить Single File Executable,
           но ни ILMerge ни современные средства не позволяют это сделать для ассемблей
           скомпилированых F# компилятором (содержащих FSharp.Core). Зато я добился того, что для того, чтобы
           собрать приложение не нужно вообще ничего кроме Windows:</P>

        <figure><code>> C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe mia-agent.csproj</code></figure>

        <p>Таким образом, мы гарантируем, что в наших экзешниках нет никаких "петь" или
           блокчейновских ренсомварей, что особенно критично для наших заказчиков. Поэтому
           любой недоверчивый пользователь может собрать "МІА: Сканування" самостоятельно не
           используя вообще никаких средств разработки!</p>

        <p>Благодаря тому, что мы выставили целевую платформу как .NET Framework 4.6 наш
           продукт "МІА: Сканування" может запускаться на любом виндовсе который младше 10 мая 2015 года,
           и при этом не требует установки никаких зависимостей (ни VC рантаймов ни .NET фреймворков)!
           Реально эта фича может сделать этот продукт народным.</p>

        <h4>TWAIN протокол</h4>

        <p>Теперь пару слов для тех, кто будет программировать ядро сканирования. Ядро сканирования
           состоит из функции ScanCallbackNative, которая будучи вызвана захватывет поток ОС пока полностью
           не отсканирует сесиию. Если вы выставили AUTOSCAN капабилити перед сканированием, то это значит,
           что вы после каждого изображения должны сами сново себя вызывать для продолжения сканирования
           пока количество страниц в фидере будет возвращаться -1. Как только оно станет 0 &mdash; это
           обозначает последнюю страницу сканирования. Имея последнюю и запомнив первую страницу (которая повернула
           колесо сканирования) мы таким образом получаем диапазон страниц (набор изображений), которые
           нам необходимо склеить для формирования многостраничного PDF или TIFF файла.<p>

        <p>Важной частью протокола является функция Rollback которая делает режимный спуск с
           максимального (7) до минимального режима (2). Логика этой работы описана на странице 3-27
           TWAIN спецификации 2.4 от марта 2017.</p>

        <p>Библиотека INFOTECH TWAINI организована таким образом, что если ее правильно грепнуть,
           то вы получите минимальный набор для сканирования с ремарками из какого
           в какой режим функция переводит контекст сканера:</p>

        <figure><code>$ cat TWAINI.cs | grep TWAIN:
        // TWAIN: 7 -> 2: Rollback: Page 3-27 of 2017-03-TWAIN-SPEC-2.4
        // TWAIN: 4 -> 4: NativeTransfer: CONTROL/CAPABILITY/SET
        // TWAIN: 4 -> 4: AutoFeed: CONTROL/CAPABILITY/SET
        // TWAIN: 4 -> 4: AutoScan: CONTROL/CAPABILITY/SET
        // TWAIN: 4 -> 4: EnableDuplex: CONTROL/CAPABILITY/SET
        // TWAIN: 4 -> 4: ProgressDriverUI: CONTROL/CAPABILITY/SET
        // TWAIN: 2 -> 3: OpenManager: CONTROL/PARENT/OPENDSM
        // TWAIN: 2 -> 2: GetDefault: CONTROL/IDENTITY/GETDEFAULT
        // TWAIN: 3 -> 3: GetDataSources: CONTROL/IDENTITY/GETFIRST,GETNEXT
        // TWAIN: 3 -> 4: OpenScanner: CONTROL/IDENTITY/OPENDS
        // TWAIN: 6 -> 6: StopFeeder: CONTROL/PENDINGXFERS/STOPFEEDER</code></figure>

        <p>Если вы хотите реально более менее детально изучить протокол, то вам конечно же нужно
           выучить наизусть тест сьют набор для прохождения TWAIN сертификации, а если
           вы (как я) немного туповат и с СДВГ, то вам лучше воспользоваться трейсером,
           который покажет вам не только все фунции и их параметры, но и правильные
           последовательности в которых это все нужно вызывать. Тут нужно сказать что TWAIN
           сканеры программируются с использованием CSV протокола. Я лично без шуток
           считаю это лучшим протоколом для энтерпрайза. Спасибо TWAIN, что не JSON, благодаря CSV эта статья как и код выглядят красивыми.</p>

        <figure><img src="img/TWAIN-1.PNG"></figure>

        <h4>Windows Forms</h4>

        <p>Как вы знаете для .NET можно делать приложения без XAML (дешево). Во времена до XAML были просто Windows Forms.
           Потом, начиная с Vista появился WPF и XAML приложения (дорогой способ выпуска продуктов, но зато с 3D-анимациями и их моделями в Adobe Premiere),
           которые до сих пор являются главным способом построения приложений наряду с COM/DCOM. К счастью политика Microsoft смягчилась
           и в Windows Store теперь будут пускать и старые дедовские Win32 приложения в том числе и Windows Forms. Поверьте,
           вы не хотите выводить на рынок WPF приложение если вы не финансируетесь нефтью напрямую.</p>

        <p>Приложение состоит из трех форм: FormScan (главная форма сканирования с отображением страниц сканирования),
           FormSetup (настройки профилей сканирования), FormSelect (выбор источника сканирования). Форма FormScan сделана
           главной, она использует активный инстанс SystemTrayIcon из которого берется иконка в нотификации.
           А вторая трей иконка используется как NotifyIcon для динамического рендеринга числа непрочитанных
           сообщений в инбоксе пользователя. Потому что если наоброт то в нотификациях будут сыпаться иконки
           с цифрами, хотелось бы этого избежать.</p>

        <p>Форма FormSetup управляет настройками сканера. Сканеры устроены таким обрзом, что предлагают вам всегда свое
           окно, которое не только позволяет вам настроить как вы будете сейчас сканировать, но и получить сериализированный
           слепок этих настроек с гарантированным отсутствием семантики (не пытайтесь это расшировать). Таким образом
           вы можете вызывать окно сканирования и сохранять настройки сканирования в профили пользователя (обычные файлы).</p>

        <p>Как правило производители систем сканирования поверх этого делают еще свой фирменное диалоговое окно, который редактирует следующие настройки:
           1) Цвет; 2) Автоподача; 3) Разрешение; 4) Белая область; 5) Авто-корректировка текста; 6) Авто-доворот.
           Вы можете выставлять либо настройки сохраненные после вызова диалогового окна сканера, либо свои настройки, где вы все контролируете,
           либо выставлять сначала настройки сканера, а поверх свои. Обычно это три классических кейса.
           Некоторые функции поддерживаются сканерами, а некоторые нужно делать самому с использованием графических библиотек.
           Всегда нужен баланс денег и времени, не пытайтесь сделать из системы сканирования Фотошоп, лучше купите LeadTools.
           В реальности 300 DPI за глаза хватает, главное, чтобы это смог распарсать синьор в очках, а не ваш кривой OCR.</p>

        <h4>Протокол сканирования</h4>

        <p>Наш Веб-сервер был представлен на страницах этого журанала еще в
           январе в статье <a href="https://tonpa.guru/stream/2021/2021-01-04%20F%23%20WebSocket%20Server.htm">F# WebSocket Server</a>.
           Здесь же мы просто покажем как будем ним пользоваться в качестве транспорта. </p>

        <p>Для захвата изображений со сканера предлагется 3-арный CSV протокол со следующим заголовком:</p>

        <figure><code>Функция,Устройство,Профиль,Вызовы</code></figure>

        <p>Четвертое поле <b>Вызовы</b> содержит вызовы разделенные плюсом <b>(+)</b>,
           а сами вызовы состоят из имени и (опционально) параметров, перед каждым из которых стоит минус <b>(-)</b>.
           Например:</p>

        <figure><code>SCAN,DS-530,maxim,AUTOSCAN+AUTOFEED
SCAN,DS-530,"",AUTOSCAN-1+COLOR-BW+DPI-300+PAGES-20</code></figure>

        <p>В случае когда третье поле <b>Профиль</b> пустое, никакой профиль, находящийся в агенте, не применяется перед сканированием.
        Когда четвертое поле пустое, тогда дополнительные настройки поверх профиля не применяются. Когда и третье и четвертое поля пусты,
        это означает, что никакие настройки CAPABILITIES не будут применятся перед сканированием:</p>

        <figure><code>SCAN,DS-530,,</code></figure>

        <p>Формат профиля сканирвания в сущности есть вызовы функций перед сканированием.
           Профиль можно передавать по сети при помощи следующего протокола:</p>

        <p>Примеры:

        <figure><code>SET,DS-530,maxim,AUTOSCAN-1+COLOR-BW+DPI-300+PAGES-20
GET,DS-530,maxim,""</code></figure>

        <p>При вызове функции GET приходит сообщение PROFILE:</p>

        <figure><code>PROFILE,DS-530,maxim,AUTOSCAN-1+COLOR-BW+DPI-300+PAGES-20</code></figure>

        <h4>WebSocket Транспорт</h4>

<p>В качестве транспорта используется протокол WebSocket и его имплементация, находящаяся в модуле <b>ws.exe</b>.</p>

        <figure><code>> ws = new WebSocket("ws://127.0.0.1:50220")
> ws.onmessage = function (evt) {
    // тут вы получаете изображения
    console.log(evt.data);
  }
> ws.send('SCAN,DS-530,,')</code></figure>

        <h4>Протокол MQTT уведомлений</h4>

         <p>Модель работы уведомлений в промышленной среде следующее: модули предприятия
            оповещают клиентов и Windows Tray приложения при помощи CSV протокола по MQTT шине.
            При запуске, агент сканирования <b>mia-agent</b> соединяется с MQTT брокером,
            адрес которого задатается на конфигурационной форме FormSetup.
            Агент "МІА: Сканування" подписывается исключительно на уведомления ERP молуля "МІА: Документообіг".
            В настройках формы FormSetup таккже предлагается набор чекбоксов &mdash; типы объектов ERP модуля,
            уведомления про которые хочет получать пользователь в область уведомлений операционной системы. Например:</p>

         <p>[+] Оброблено підлеглими<br>
            [+] На погодження<br>
            [&nbsp; ] На підпис<br>
            [&nbsp; ] Депутатські звернення</p>

         <p>Полный перечень категорий должен быть реализован как Elixir модуль,
            часть системы "МІА: Документообіг", который посылает оповещения для "МІА: Сканування" через MQTT брокер.</p>

<h4>Формат MQTT уведомлений</h4>

<p>Уведомления посылаются в CSV формате:</P>

        <figure><code>Модуль, Тип, Приоритет, Идентификатор, Текст, URL</code></figure>

<p>Примеры уведомлений:</P>

        <figure><code>СЕД, Документ, 1, ЗГ-001, Оброблено підлеглими, ?p=ВИХ_ЗГ-001_ДП
СЕД, Документ, 2, 11214, На погодження, ?p=ВИХ_11214_ДП</code></figure>

<p>Префиксы топиков:</p>

        <figure><code>/mia-crm/# -- Документооборот
/mia-acc/# -- Персонал
/mia-fin/# -- Учет и Отчетность</code></figure>

        <br/>
        <hr/>
        <br/>

     <p><a href="https://github.com/erpuno/scan">SCAN</a> — Windows Tray Agent "МІА: Сканування", Companion Application of "МІА: Документообіг".</p>

    </section>
</main>
<footer><img height=64 src="https://openmoji.org/data/color/svg/E329.svg"/></footer>
</body>
</html>
